<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo建立博客</title>
    <url>/2022/07/01/Hexo%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><ol>
<li>一直想拥有一个自己的域名来作为个人博客，后来发现通过github pages + hexo可以帮助我们免费生成静态网址，不用购买域名就可以简便地搭建一个自由的个人博客，且不需要服务器及后台。</li>
<li>Hexo是一个快速、简洁且高效的博客框架，支持 Markdown，可以部署到GitHub Pages平台。</li>
</ol>
<h2 id="二、准备环境"><a href="#二、准备环境" class="headerlink" title="二、准备环境"></a>二、准备环境</h2><ol>
<li>需要注册一个Github账号。</li>
<li>需要下载Node.js以及Git.</li>
<li>安装Hexo，在Git Bash中运行以下命令：</li>
</ol>
<p>​      <code>npm install -g hexo-cli</code></p>
<ol start="4">
<li>初始化Hexo，在Git Bash中运行以下命令：</li>
</ol>
<p>​        这些即为Hexo初始化文件的路径。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init &lt;folder&gt;<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> &lt;folder&gt;<br><span class="hljs-variable">$</span> npm install<br></code></pre></td></tr></table></figure>

<ol start="5">
<li><p>启动服务器。在<strong>此路径</strong>下，Git Bash中输入以下命令，运行即可：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>可通过浏览器访问<a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p>
</li>
</ol>
<h2 id="三、博客搭建"><a href="#三、博客搭建" class="headerlink" title="三、博客搭建"></a>三、博客搭建</h2><h3 id="3-1、创建仓库"><a href="#3-1、创建仓库" class="headerlink" title="3.1、创建仓库"></a>3.1、创建仓库</h3><ul>
<li>新建一个名为<code>你的账户名.github.io</code>的仓库，这样以后就可以通过http:&#x2F;&#x2F;《账户名称》.github.io，进行访问。（<strong>注意</strong>仓库名字一定为你的<strong>账户名</strong>,即登录github时使用的名称，而不是昵称）</li>
</ul>
<h3 id="3-2、安装hexo-deployer-git插件"><a href="#3-2、安装hexo-deployer-git插件" class="headerlink" title="3.2、安装hexo-deployer-git插件"></a>3.2、安装<code>hexo-deployer-git</code>插件</h3><ul>
<li>在Git Bash中运行以下命令：</li>
</ul>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">$ npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure>

<h3 id="3-3、配置SSH-key"><a href="#3-3、配置SSH-key" class="headerlink" title="3.3、配置SSH key"></a>3.3、配置SSH key</h3><ol>
<li>创建一个 SSH key ，在Git Bash中输入以下命令， 回车三下：</li>
</ol>
<figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh-keygen -t rsa -C <span class="hljs-string">&quot;邮箱地址&quot;</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>找到秘钥文件内容，在Git Bash中输入以下命令：</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cat</span> id_rsa.pub<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>复制密钥文件内容，添加到github即可。</li>
</ol>
<h3 id="3-4、修改-config-yml文件及推送到GithubPages"><a href="#3-4、修改-config-yml文件及推送到GithubPages" class="headerlink" title="3.4、修改_config.yml文件及推送到GithubPages"></a>3.4、修改_config.yml文件及推送到GithubPages</h3><ol>
<li>修改<code>_config.yml</code>（在站点目录下）。文件末尾修改为：</li>
</ol>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># Deployment</span><br><span class="hljs-meta">## Docs: https:<span class="hljs-comment">//hexo.io/docs/deployment.html</span></span><br><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:<span class="hljs-params">&lt;Github账号名称&gt;</span>/<span class="hljs-params">&lt;Github账号名称&gt;</span>.github.io.git<br><span class="hljs-symbol">  branch:</span> master<br><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>推送到GithubPages。在Git Bash中依次输入以下命令：</li>
</ol>
<figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo g<br><span class="hljs-variable">$ </span>hexo d<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>现在即可通过http:&#x2F;&#x2F;《账户名称》.github.io进行访问。</li>
</ol>
<h2 id="四、更改主题"><a href="#四、更改主题" class="headerlink" title="四、更改主题"></a>四、更改主题</h2><h3 id="4-1-安装主题"><a href="#4-1-安装主题" class="headerlink" title="4.1 安装主题"></a>4.1 安装主题</h3><p>下载主题,例如next主题。</p>
<p><code>$ cd your-hexo-site</code><br><code>$ git clone https://github.com/iissnan/hexo-theme-next themes/next</code></p>
<h3 id="4-2-启用主题"><a href="#4-2-启用主题" class="headerlink" title="4.2 启用主题"></a>4.2 启用主题</h3><p>更改站点配置文件<code>_config.yml</code> 的theme字段，为主题文件夹的名称。</p>
<h3 id="4-3-配置主题"><a href="#4-3-配置主题" class="headerlink" title="4.3 配置主题"></a>4.3 配置主题</h3><p>修改主题目录下的_config.yml配置文件可对主题进行配置。具体设置可参考该主题的配置文档。</p>
<h2 id="五、写博客"><a href="#五、写博客" class="headerlink" title="五、写博客"></a>五、写博客</h2><h3 id="5-1-新建文章"><a href="#5-1-新建文章" class="headerlink" title="5.1 新建文章"></a>5.1 新建文章</h3><p>通过命令行<code>hexo new &quot;postName&quot;</code>或<code>hexo n &quot;postName&quot;</code><br>可新建一篇名为postName的文章，打开博客目录中 source&#x2F;_posts 文件夹中的对应Markdown文档即可开始撰写博文。</p>
]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS</title>
    <url>/2023/04/11/CSS/</url>
    <content><![CDATA[<h2 id="CSS语法规范"><a href="#CSS语法规范" class="headerlink" title="CSS语法规范"></a>CSS语法规范</h2><p>CSS规则由两个主要的部分构成：选择器以及一条或多条声明（包括属性和属性值）：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>            <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><p>选择器就是根据不同的需求把不同的标签选出来。</p>
<p>选择器分为基础选择器和复合选择器两大类。</p>
<h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><p>基础选择器是由单个选择器组成的。</p>
<p>基础选择器又包括：标签选择器、类选择器、Id选择器和通配符选择器。</p>
<h4 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h4><p>标签选择器是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>            <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><p>类指标签中的class。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">.类名 &#123;<br>	属性:属性值;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>长类名可以使用“-”分割。</p>
<p>注意类名命名规范。</p>
<h4 id="多类名选择器"><a href="#多类名选择器" class="headerlink" title="多类名选择器"></a>多类名选择器</h4><p>可以给一个标签指定多个类名，多个类名中间使用空格分开，这样标签就可以具有多个类名的样式。</p>
<p>可以把一些相同的样式放到一个类里。</p>
<h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><p>id选择器可以为标有特定id的HTML元素指定特定的样式。</p>
<p>HTML元素以id属性来设置id选择器，CSS中id选择器以”#”来定义。</p>
<p>同一个HTML页面不能出现相同的 id，哪怕他们不是一个类型。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">id</span>名 &#123;</span><br>	属性：属性值;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h4><p>通配符选择器使用“*”定义，表示选取页面中所有标签。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">* &#123;<br>	属性：属性值<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h3><p>复合选择器是建立在基础选择器之上，由两个或多个基础选择器，通过不同的方式组合而成的。</p>
<h4 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h4><p>后代选择器可以选择父元素里的子元素。</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><code class="hljs dust"><span class="language-xml">元素一 元素二 </span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">	样式声明</span><br><span class="hljs-template-variable">&#125;</span><br></code></pre></td></tr></table></figure>

<p>上述语法表示选择元素一里的所有元素二（包括所有的后代元素）。</p>
<p>元素一和元素二可以是任意基础选择器。</p>
<h4 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h4><p>子元素选择器只能选择作为某元素的最近一级子元素。</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><code class="hljs dust"><span class="language-xml">元素1&gt;元素1 </span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">	样式声明</span><br><span class="hljs-template-variable">&#125;</span><br></code></pre></td></tr></table></figure>

<p>上述语法表示选择元素1里面的所有直接后代（子元素）元素2。</p>
<h4 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h4><p>并集选择器可以选择多组标签，同时为他们定义相同的样式。</p>
<p>并集选择器是各选择器通过英文逗号（,）连接而成，任何形式的选择器都可以作为并集选择器的一部分。</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><code class="hljs dust"><span class="language-xml">元素1,元素2 </span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">	样式声明</span><br><span class="hljs-template-variable">&#125;</span><br></code></pre></td></tr></table></figure>

<p>上述语法表示选择元素1和元素2。</p>
<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>伪类选择器用于向某些选择器添加特殊效果，比如给链接添加特殊效果，或选择第1个，第n个元素。</p>
<p>伪类选择器的书写特点是用冒号（:）表示。</p>
<h4 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h4><ul>
<li>a:link。选择所有未被访问的链接。</li>
<li>a:visited。选择所有已被访问的链接。</li>
<li>a:hover。选择鼠标指针位于其上的链接。</li>
<li>a:active。选择活动链接（鼠标点击未弹起的链接）。</li>
</ul>
<p>链接伪类应该按顺序书写：link、visited、hover、active。</p>
<h4 id="focus类选择器"><a href="#focus类选择器" class="headerlink" title=":focus类选择器"></a>:focus类选择器</h4><p>:focus类选择器用于选取获得焦点（焦点就是光标）的表单元素。</p>
<h2 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h2><p>字体属性用于定义字体系列、大小、粗细和文字样式（如斜体）。</p>
<h3 id="字体系列"><a href="#字体系列" class="headerlink" title="字体系列"></a>字体系列</h3><p>CSS使用font-family属性定义文本的文字系列。</p>
<p>可以设置多种字体，先读取前面的字体，各种字体之间使用逗号隔开。</p>
<p>如果有空格隔开的多个单词组成的字体加引号。</p>
<p>可以给body标签指定整个页面文本的文字系列。</p>
<h3 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h3><p>CSS使用font-size属性定义字体的大小。</p>
<p>单位px（像素）是网页最常用的单位。</p>
<p>不同浏览器默认显示的字号大小可能不一致，我们尽量给一个明确的大小。</p>
<p>可以给body标签指定整个页面文本的文字系列（标题标签比较特殊，需要单独指定文字大小）。</p>
<h3 id="字体粗细"><a href="#字体粗细" class="headerlink" title="字体粗细"></a>字体粗细</h3><p>CSS使用font-weight属性设置文本字体的粗细。</p>
<p>属性值：</p>
<p>normal：默认值（不加粗）。</p>
<p>bold：定义粗体（加粗）。</p>
<p>100~900：400等同于normal，而700等同于bold，注意这个数字后面不跟单位。</p>
<h3 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h3><p>CSS使用font-style设置文本风格。</p>
<p>属性值：<br>normal：默认值，浏览器显示标准字体样式。</p>
<p>italic：斜体字体样式。</p>
<h3 id="字体复合属性"><a href="#字体复合属性" class="headerlink" title="字体复合属性"></a>字体复合属性</h3><p>字体复合属性可以把文字样式综合。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">p &#123;<br>	<span class="hljs-built_in">font</span>: <span class="hljs-built_in">font</span>-<span class="hljs-built_in">style</span> <span class="hljs-built_in">font</span>-weight  <span class="hljs-built_in">font</span>-size/line-<span class="hljs-built_in">height</span> <span class="hljs-built_in">font</span>-family; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>书写格式顺序不能变。</p>
<p>不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性。</p>
<h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><p>CSS文本属性可定义文本的外观，比如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等。</p>
<h3 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h3><p>color属性用于定义文本的颜色。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>	<span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>表示形式：</p>
<ul>
<li>预定义的颜色值：例如：red、blue等。</li>
<li>十六进制：例如：FF0000</li>
<li>RGB代码：例如：rgb(255,0,0)或rgb(100%,0%,0%)</li>
</ul>
<h3 id="文本对齐"><a href="#文本对齐" class="headerlink" title="文本对齐"></a>文本对齐</h3><p>text-align属性用于设置元素文本内容的水平对齐方式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>	<span class="hljs-attribute">text-align</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>属性值：</p>
<ul>
<li>left：左对齐。</li>
<li>right：右对齐。</li>
<li>center：居中对齐。</li>
</ul>
<h3 id="装饰文本"><a href="#装饰文本" class="headerlink" title="装饰文本"></a>装饰文本</h3><p>text-decoration属性规定添加到文本的修饰。可以给文本添加下划线、删除线、上划线等。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>	<span class="hljs-attribute">text-decoration</span>: none;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>属性值：</p>
<ul>
<li>none：默认，没有装饰线。</li>
<li>underline：下划线，链接a自带下划线。</li>
<li>overline：上划线。</li>
<li>line-through：删除线。</li>
</ul>
<h3 id="文本缩进"><a href="#文本缩进" class="headerlink" title="文本缩进"></a>文本缩进</h3><p>text-indent属性用来设置元素内文本的第一行的缩进，通常是将段落的首行缩进，可以是负值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>	<span class="hljs-attribute">text-indent</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>	<span class="hljs-attribute">text-indent</span>: <span class="hljs-number">10em</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>em是一个相对单位，就是当前元素（font-size）1个文字的大小，如果当前元素没有设置大小，则会按照父元素的1个文字大小。</p>
<h3 id="行间距"><a href="#行间距" class="headerlink" title="行间距"></a>行间距</h3><p>line-height属性用于设置行间的距离（行高）。可以控制文字行与行之间的距离的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>	<span class="hljs-attribute">line-height</span>: <span class="hljs-number">25px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>行间距包括上间距、文本高度、下间距。</p>
<h2 id="CSS引入方式"><a href="#CSS引入方式" class="headerlink" title="CSS引入方式"></a>CSS引入方式</h2><ul>
<li>内部样式表。内部样式表是写到HTML页面内部，将所有的CSS代码抽取出来，单独放到一个style标签中。</li>
<li>行内样式表。行内样式表是在元素标签内部的style属性中设置CSS样式。</li>
<li>外部样式表。样式单独写到CSS文件中，在HTML页面中通过link标签引入。</li>
</ul>
<h2 id="CSS的元素显示模式"><a href="#CSS的元素显示模式" class="headerlink" title="CSS的元素显示模式"></a>CSS的元素显示模式</h2><p>元素显示模式就是元素以什么方式进行显示，比如div独占一行，span一行可以放多个。</p>
<p>HTML元素一般分为块元素和行内元素两种类型。</p>
<h3 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h3><p>常见的块元素：h1、p、div、li等。</p>
<p>块元素的特点：</p>
<ul>
<li>独占一行。</li>
<li>高度，宽度、外边距和内边距都可以控制。</li>
<li>宽度默认是父级宽度的100%。</li>
<li>是一个容器，里面可以放行内或者块元素。</li>
</ul>
<p>注意文字类的元素内不能使用块级元素，比如：p、h1。</p>
<h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><p>常见的行内元素：a、span、b、i等。</p>
<p>行内元素的特点：</p>
<ul>
<li>相邻行内元素在一行上，一行可以显示多个。</li>
<li>高宽直接设置是无效的。</li>
<li>默认宽度就是它本身内容的宽度。</li>
<li>行内元素只能容纳文本或其它行内元素。（链接a里可以放块级元素，但是转换一下块级模式更安全）</li>
</ul>
<p>注意链接里不能放链接。</p>
<h3 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h3><p>行内元素中有几个特殊的标签：&lt;img&#x2F;&gt;、&lt;input&#x2F;&gt;、&lt;td&gt;，它们同时具有块元素和行内元素的特点。</p>
<p>行内块元素的特点：</p>
<ul>
<li>和相邻行内元素（行内块）在一行上，但是之间会有空隙。一行可以显示多个（行内元素特点）。</li>
<li>默认宽度就是它本身内容的宽度（行内元素的特点）。</li>
<li>高度，宽度，外边距以及内边距都可以控制（块级元素的特点）。</li>
</ul>
<h3 id="元素显示模式转换"><a href="#元素显示模式转换" class="headerlink" title="元素显示模式转换"></a>元素显示模式转换</h3><p>一个模式需要另外一种模式的特性。</p>
<p>行内元素转换为块级元素：display: block;</p>
<p>块级元素转换为行内元素： display: inline;</p>
<p>转换为行内块元素： display: inline-block;</p>
<p>行内块元素之间会有空白间隙。</p>
<h2 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h2><h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><p>background-color属性定义了元素的背景颜色。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-color</span>: 颜色;<br></code></pre></td></tr></table></figure>

<p>一般情况下元素的背景颜色默认值是transparent（透明）。</p>
<h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p>background-image属性描述了元素的背景图像，优点是便于控制位置。</p>
<p>参数值：</p>
<ul>
<li>none。无背景的（默认）</li>
<li>url。使用相对或绝对地址指定背景图像。</li>
</ul>
<h3 id="背景平铺"><a href="#背景平铺" class="headerlink" title="背景平铺"></a>背景平铺</h3><p>background-repeat属性可以控制背景图片的平铺效果。</p>
<p>参数值：</p>
<ul>
<li>repeat。背景图像在纵向和横向上平铺（默认）。</li>
<li>no-repeat。背景图像不平铺。</li>
<li>repeat-x。背景图像在横向平铺。</li>
<li>repeat-y。背景图像在纵向平铺。</li>
</ul>
<p>页面元素既可以有背景图片也可以有背景颜色，只不过背景图片会压住背景颜色。</p>
<h3 id="背景图片位置"><a href="#背景图片位置" class="headerlink" title="背景图片位置"></a>背景图片位置</h3><p>background-position属性可以改变图片在背景中的位置。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">background-position: x y;<br></code></pre></td></tr></table></figure>

<p>参数代表的意思是： x坐标和y坐标。可以使用方位名词（top、center、bottom、left、center、right）或者精确单位（百分数、由数字和单位组成的长度值）。</p>
<h4 id="参数是方位名词"><a href="#参数是方位名词" class="headerlink" title="参数是方位名词"></a>参数是方位名词</h4><p>如果指定的两个值都是方位名词，则两个值前后顺序无关。</p>
<p>如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐。</p>
<h4 id="参数是精确单位"><a href="#参数是精确单位" class="headerlink" title="参数是精确单位"></a>参数是精确单位</h4><p>如果参数是精确坐标，那么第一个是x坐标，第二个是y坐标。</p>
<p>如果只指定一个数值，那么该数值是x坐标，另一个默认垂直居中。</p>
<h4 id="参数是混合单位"><a href="#参数是混合单位" class="headerlink" title="参数是混合单位"></a>参数是混合单位</h4><p>如果指定的两个值是精确单位和方位名词混合使用，则第一个值是x坐标，第二个值是y坐标。</p>
<h3 id="背景图像固定"><a href="#背景图像固定" class="headerlink" title="背景图像固定"></a>背景图像固定</h3><p>background-attachment属性设置背景图像是否固定或者随着页面的其余部分滚动。可以制作视差滚动效果。</p>
<p>参数值：</p>
<ul>
<li>scroll。背景图像是随对象内容滚动。（默认）</li>
<li>fixed。背景图像固定。</li>
</ul>
<h3 id="背景复合写法"><a href="#背景复合写法" class="headerlink" title="背景复合写法"></a>背景复合写法</h3><p>背景属性可以合并简写在一个属性background中。简写属性没有特定书写顺序。但一般按照：</p>
<p>background：背景颜色 背景图片地址 背景平铺 背景图像滚动 背景位置;</p>
<h3 id="背景颜色半透明"><a href="#背景颜色半透明" class="headerlink" title="背景颜色半透明"></a>背景颜色半透明</h3><p>背景颜色半透明效果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">background</span>: rgba(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure>

<p>最后一个参数alpha透明度，取值范围在0~1之间。0是百分之百透明，1是百分之百不透明。</p>
<p>背景半透明是指盒子背景半透明，盒子里面的内容不受影响。</p>
<h2 id="CSS的三个特性"><a href="#CSS的三个特性" class="headerlink" title="CSS的三个特性"></a>CSS的三个特性</h2><h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h3><p>相同选择器给设置相同的样式，此时一个样式就会覆盖另一个冲突样式。层叠性主要解决样式冲突的问题。</p>
<p>层叠性原则：样式冲突遵循就近原则，哪个样式离结构近就执行哪个样式。</p>
<h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>子标签会继承父标签中的某些样式（text-、font-、line-这些元素开头的可以继承），如文本颜色和字号。</p>
<p>行高的继承性：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">p &#123;<br>	<span class="hljs-built_in">font</span>: <span class="hljs-built_in">font</span>-<span class="hljs-built_in">style</span> <span class="hljs-built_in">font</span>-weight  <span class="hljs-built_in">font</span>-size/line-<span class="hljs-built_in">height</span> <span class="hljs-built_in">font</span>-family; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中的line-height可以加单位，也可以不加。</p>
<p>如果不加单位则表示一个倍数。</p>
<p>设此数为1.5，如果子元素没有设置行高，则子元素的行高为当前子元素文字大小*1.5。</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>当同一个元素指定多个选择器，就会有优先级的产生。</p>
<ul>
<li>选择器相同，则执行层叠性。</li>
<li>选择器不同，则根据选择器权重执行。</li>
</ul>
<p>选择器权重：</p>
<p>![](E:\笔记\笔记图片\Screenshot 2023-01-01 184923.png)</p>
<p>权重叠加：如果是复合选择器，则会有权重叠加，需要计算权重（权重不会进位）。</p>
<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>盒子模型就是把HTML页面中的布局元素看做是一个矩形的盒子，也就是一个盛装内容的容器。它包括边框、内边距、外边距、实际内容。</p>
<h3 id="边框（border）"><a href="#边框（border）" class="headerlink" title="边框（border）"></a>边框（border）</h3><p>border可以设置元素的边框。边框有三个属性：</p>
<ul>
<li>border-width。定义边框粗细，单位是px。</li>
<li>border-style。边框的样式（实线solid、虚线dashed、点线dotted等）。</li>
<li>border-color。边框颜色。</li>
</ul>
<p>border的复合写法（不要求顺序）：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid blue;<br></code></pre></td></tr></table></figure>

<p>border边框可以分开写，如：border-top、border-bottom。</p>
<p>边框会额外增加盒子的实际大小。</p>
<h4 id="表格的细线边框"><a href="#表格的细线边框" class="headerlink" title="表格的细线边框"></a>表格的细线边框</h4><p>border-collapse属性控制浏览器绘制表格边框的方式，它控制相邻单元格的边框。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">border</span>-<span class="hljs-built_in">collapse</span>: <span class="hljs-built_in">collapse</span>;<br></code></pre></td></tr></table></figure>

<p>border-collapse: collapse;表示相邻边框合并在一起。</p>
<h3 id="内边距（padding）"><a href="#内边距（padding）" class="headerlink" title="内边距（padding）"></a>内边距（padding）</h3><p>padding属性用于设置内边距，即边框与内容之间的距离。</p>
<p>属性：padding-left、padding-right、padding-top、padding-bottom。</p>
<p>简写形式：</p>
<p>![](E:\笔记\笔记图片\Screenshot 2023-01-02 192154.png)</p>
<p>padding会额外增加盒子的实际大小。但是如果盒子本身没有指定width&#x2F;height属性，则此时padding不会撑开盒子大小。</p>
<h3 id="外边距（margin）"><a href="#外边距（margin）" class="headerlink" title="外边距（margin）"></a>外边距（margin）</h3><p>margin属性用于设置外边距，即控制盒子与盒子之间的距离。</p>
<p>属性：margin-left、margin-right、margin-top、margin-bottom。</p>
<p>简写方式和padding一致。</p>
<p>行内元素只有设置左右外边距会有作用，上下外边距不会有作用。</p>
<p>外边距可以让块级盒子水平居中，但是必须要满足两个条件：</p>
<ul>
<li>盒子必须制定宽度。</li>
<li>盒子左右外边距设为auto。</li>
</ul>
<p>行内元素和行内块元素可以给其父元素添加text-align：center即可。</p>
<p>使用margin定义块级元素的垂直外边距时，可能会出现外边距的合并（只是上外边距会出现此情况）。</p>
<p>对于两个嵌套关系的块元素，如父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的上外边距值。</p>
<p>解决方案：</p>
<p>1.为父元素定义上边框。</p>
<p>2.为父元素定义上内边距。</p>
<p>3.为父元素添加overflow:hidden。</p>
<p>4.还有其他方法，如浮动、固定、绝对定位的盒子不会有塌陷问题。</p>
<p>可以利用margin设置负值，解决盒子与盒子之间边框紧挨变粗的问题。</p>
<h3 id="清除内外边距"><a href="#清除内外边距" class="headerlink" title="清除内外边距"></a>清除内外边距</h3><p>网页元素很多都带有默认的内外边距，而且不同浏览器默认的也不一致。因此在布局前，首先要清除网页元素的内外边距。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">* &#123;<br>	<span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>	<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="圆角边框"><a href="#圆角边框" class="headerlink" title="圆角边框"></a>圆角边框</h3><p>border-radius属性用于设置元素的外边框圆角。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">border</span>-<span class="hljs-built_in">radius</span>:<span class="hljs-built_in">length</span>;<br></code></pre></td></tr></table></figure>

<p>radius半径（圆的半径）原理：圆与边框的交集形成圆角效果。</p>
<p>参数值（显示的效果最值为短边的一半，超过效果不变）可以为数值或百分比（50%为一个椭圆，如果是正方形50%为圆，超过50%的效果仍为50%的效果）。</p>
<p>如果是正方形，想要设置成一个圆，把数值修改为高度或宽度的一半，或写成50%。</p>
<p>该属性是一个简写属性，可以跟四个值，分别表示左上角、右上角、左下角、右下角。</p>
<p>分开写：border-top-left-radius等。</p>
<h3 id="盒子阴影"><a href="#盒子阴影" class="headerlink" title="盒子阴影"></a>盒子阴影</h3><p>box-shadow属性可以为盒子添加阴影。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">box-shadow: </span>h-<span class="hljs-keyword">shadow </span>v-<span class="hljs-keyword">shadow </span><span class="hljs-keyword">blur </span>spread  color <span class="hljs-keyword">inset;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>h-shadow。必需，水平阴影的位置，允许负值。</li>
<li>v-shadow。必需，垂直阴影的位置，允许负值。</li>
<li>blur。可选，模糊距离。</li>
<li>spread。可选，阴影的尺寸。</li>
<li>color。可选。阴影的颜色。</li>
<li>inset。可选，将外部阴影（outset）改为内部阴影。默认的是外部阴影，但是不能写这个词，否则阴影无效。</li>
</ul>
<p>盒子阴影不占用空间，不会影响其它盒子排列。</p>
<h3 id="文字阴影"><a href="#文字阴影" class="headerlink" title="文字阴影"></a>文字阴影</h3><p>text-shadow属性可以设置文字阴影。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">text-<span class="hljs-keyword">shadow: </span>h-<span class="hljs-keyword">shadow </span>v-<span class="hljs-keyword">shadow </span><span class="hljs-keyword">blur </span>color;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>h-shadow。必需，水平阴影的位置，允许负值。</p>
</li>
<li><p>v-shadow。必需，垂直阴影的位置，允许负值。</p>
</li>
<li><p>blur。可选，模糊距离。</p>
</li>
<li><p>color。可选。阴影的颜色。</p>
</li>
</ul>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p>传统网页布局的三种方式：</p>
<ul>
<li>普通流（标准流、文档流），就是标签按照规定好的默认方式排列。块级元素独占一行，从上向下顺序排列，行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。</li>
<li>浮动。</li>
<li>定位。</li>
</ul>
<p>浮动可以改变元素标签的默认排列方式。</p>
<p>多个块级元素纵向排列用标准列，多个块级元素横向排列用浮动。</p>
<p>float属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">选择器 &#123;<span class="hljs-attribute">float</span>: 属性值;&#125;<br></code></pre></td></tr></table></figure>

<p>属性值：</p>
<ul>
<li>none，元素不浮动，默认值。</li>
<li>left，元素向左浮动。</li>
<li>right，元素向右浮动。</li>
</ul>
<p>浮动特性：</p>
<ul>
<li><p>浮动元素会脱离标准流（浮），移动到指定位置（动），即脱标，浮动的盒子不再<strong>保留原先的位置</strong>。</p>
</li>
<li><p>浮动元素会一行内显示并且元素顶部对齐。如果多个盒子都设置了浮动，则它们会按照属性值一行内显示并且顶端对齐排列。</p>
<p>浮动的元素是互相贴靠在一起的（不会有间隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。</p>
</li>
<li><p>浮动元素会具有行内块元素的特性。任何元素都可以浮动，不管原先是什么模式的元素，添加浮动之后具有行内块元素相似的特性。如果行内元素有了浮动，则不需要转换成块级&#x2F;行内块元素就可以直接给宽度和高度。如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来定。</p>
</li>
</ul>
<p>为了约束浮动元素的位置，一般先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。</p>
<p>一个盒子里面有多个子盒子，如果其中一个盒子浮动了，那么其他兄弟也应该浮动，防止出现其它问题。</p>
<p>浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流。</p>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>父级盒子很多情况下不方便给高度，但是子盒子浮动不占有位置，最后父级盒子高度为0时，就会影响下面的标准流盒子。</p>
<p>清除浮动本质：</p>
<ul>
<li>清除浮动的本质是清除浮动元素造成的影响。</li>
<li>如果父盒子本身有高度，则不需要清除浮动。</li>
<li>清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了。</li>
</ul>
<h4 id="清除浮动的策略"><a href="#清除浮动的策略" class="headerlink" title="清除浮动的策略"></a>清除浮动的策略</h4><p>清除浮动的策略是闭合浮动。只让浮动在父盒子内部影响，不影响父盒子外面的其它盒子。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">选择器 &#123;<span class="hljs-attribute">clear</span>: 属性值&#125;;<br></code></pre></td></tr></table></figure>

<p>属性值：</p>
<ul>
<li>left，不允许左侧有浮动元素，清除左侧浮动元素的影响。</li>
<li>right，不允许右侧有浮动元素，清除右侧浮动元素的影响</li>
<li>both，同时清除左右两侧浮动的影响（常用）。</li>
</ul>
<h4 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h4><h5 id="额外标签法"><a href="#额外标签法" class="headerlink" title="额外标签法"></a>额外标签法</h5><p>额外标签法会在浮动元素末尾添加一个空的标签。例如&lt; div style&#x3D;”clear:both”&gt;&lt;&#x2F;div&gt;,或者其它标签（如&lt;br&#x2F;&gt;等），这个新的空标签必须是块级元素。</p>
<p>缺点是添加了无意义的标签，结构化较差。</p>
<h5 id="父级添加overflow"><a href="#父级添加overflow" class="headerlink" title="父级添加overflow"></a>父级添加overflow</h5><p>给父级元素添加overflow属性，将属性值设置为hidden、auto或scroll。</p>
<p>优点：代码简洁。</p>
<p>缺点：无法显示溢出的部分。</p>
<h5 id="after伪元素法"><a href="#after伪元素法" class="headerlink" title=":after伪元素法"></a>:after伪元素法</h5><p>:after方式是额外标签法的升级版，给父元素添加：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>	<span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>	<span class="hljs-attribute">display</span>: block;<br>	<span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>	<span class="hljs-attribute">clear</span>: both;<br>	<span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br><span class="hljs-comment">//IE6、7专有</span><br><span class="hljs-selector-class">.clearfix</span> &#123;<br>	*zoom: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>优点：没有增加额外标签，结构简单。</p>
<p>缺点：照顾低版本浏览器。</p>
<h5 id="双伪元素清除浮动"><a href="#双伪元素清除浮动" class="headerlink" title="双伪元素清除浮动"></a>双伪元素清除浮动</h5><p>给父元素添加：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:before</span>,<br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>	<span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>	<span class="hljs-attribute">display</span>: table;<br>&#125;<br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>	<span class="hljs-attribute">clear</span>: both;<br>&#125;<br><span class="hljs-comment">//IE6、7专有</span><br><span class="hljs-selector-class">.clearfix</span> &#123;<br>	*zoom: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="CSS书写顺序"><a href="#CSS书写顺序" class="headerlink" title="CSS书写顺序"></a>CSS书写顺序</h2><p>![](E:\笔记\笔记图片\Screenshot 2023-01-09 135416.png)</p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>定位：将盒子定在某一个位置，所以定位也是在摆放盒子，按照定位的方式移动盒子。</p>
<p>定位由定位模式和边偏移组成。定位模式用于指定一个元素在文档中的定位方式，边偏移决定了该元素的最终位置。</p>
<p>定位模式通过position属性设置，属性值：</p>
<ul>
<li>static，静态定位。</li>
<li>relative，相对定位。</li>
<li>absolute，绝对定位。</li>
<li>fixed，固定定位。</li>
</ul>
<p>边偏移有4个属性：</p>
<ul>
<li>top，顶端偏移量（相对于父元素），属性值例如：10px。</li>
<li>right，右侧偏移量（相对于父元素）。</li>
<li>bottom，低端偏移量（相对于父元素）。</li>
<li>left，左侧偏移量（相对于父元素）。</li>
</ul>
<h3 id="静态定位static"><a href="#静态定位static" class="headerlink" title="静态定位static"></a>静态定位static</h3><p>静态定位是元素的默认定位方式，无定位的意思。</p>
<p>静态定位按照标准流特性摆放位置，没有边偏移。</p>
<h3 id="相对定位relative"><a href="#相对定位relative" class="headerlink" title="相对定位relative"></a>相对定位relative</h3><p>相对定位是元素在移动位置的时候，是相对于它原来的位置。</p>
<p>原来的位置依然保留，后面的盒子仍然以标准流的方式对待它。</p>
<h3 id="绝对定位absolute"><a href="#绝对定位absolute" class="headerlink" title="绝对定位absolute"></a>绝对定位absolute</h3><p>绝对定位是元素在移动的时候，是相对于它的祖先元素。</p>
<p>如果没有祖先元素或者祖先元素没有定位，则以浏览器为准进行定位。</p>
<p>如果祖先元素有定位（相对，绝对，固定），则以最近一级的有定位祖先元素为准移动位置。</p>
<p>绝对定位不再占有原先的位置。</p>
<p>自绝父相：子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其它的兄弟盒子。父盒子需要加定位限制子盒子在父盒子内显示，父盒子布局时，需要占有位置，因此父盒子要为相对定位。</p>
<h3 id="固定定位fixed"><a href="#固定定位fixed" class="headerlink" title="固定定位fixed"></a>固定定位fixed</h3><p>固定定位是元素固定于浏览器可视区的位置。主要使用场景：可以在浏览器页面滚动时，元素的位置不会改变。</p>
<p>固定定位特点：以浏览器的可视窗口为参照点移动元素，固定定位不在占有原先的位置。</p>
<p>元素固定在版心右侧位置：</p>
<p>1.让固定定位的盒子left：50%，走到浏览器可视区一半的位置。</p>
<p>2.让固定定位的盒子margin-left：版心宽度一半的距离。</p>
<h3 id="粘性定位sticky"><a href="#粘性定位sticky" class="headerlink" title="粘性定位sticky"></a>粘性定位sticky</h3><p>粘性定位可以认为是相对定位和固定定位的混合。</p>
<p>特点：以浏览器的可视窗口为参照点移动元素，占有原先的位置，必须添加一个偏移量才有效。</p>
<h3 id="定位叠放次序z-index"><a href="#定位叠放次序z-index" class="headerlink" title="定位叠放次序z-index"></a>定位叠放次序z-index</h3><p>在使用定位布局时可能会出现盒子重叠的情况，此时，可以使用z-index来控制盒子的前后次序。</p>
<p>数值可以是正整数，负整数或0，默认是auto，数字越大盒子越靠上。</p>
<p>如果属性值相同，则按照书写顺序，后来居上。</p>
<p>数字后面不能加单位。</p>
<p>只有定位的盒子才有z-index属性。</p>
<p>绝对定位和固定定位的盒子不能通过margin:0 auto实现水平居中，可以通过：</p>
<p>1.left：50%，让盒子的左侧移动到父级元素的水平中心位置。</p>
<p>2.margin-left：-盒子自身宽度一半，让盒子向左移动自身宽度一半。</p>
<p>垂直居中同理。</p>
<p>绝对定位和固定定位与浮动类似：</p>
<ul>
<li>行内元素添加固定或绝对定位，可以直接设置长度和宽度。</li>
<li>行块级元素添加固定或绝对定位，如果不给宽度或者高度，默认大小是内容的大小。</li>
<li>脱标的盒子不会触发外边距塌陷（浮动元素、绝对、固定定位）。</li>
</ul>
<p>绝对定位和固定定位会完全压住下面所有的内容，而浮动元素只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片）。因为浮动产生的最初目的是做文字环绕效果的，文字会围绕<strong>浮动</strong>元素。</p>
<h2 id="元素的显示与隐藏"><a href="#元素的显示与隐藏" class="headerlink" title="元素的显示与隐藏"></a>元素的显示与隐藏</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>display属性用于设置一个元素如何显示。</p>
<p>display:none;隐藏元素。</p>
<p>display:block;除了转换为块级元素之外，同时还有显示元素的意思。</p>
<p>display隐藏元素后，不再占有原来的位置。</p>
<h3 id="visibility"><a href="#visibility" class="headerlink" title="visibility"></a>visibility</h3><p>visibility属性用于指定一个元素可见还是隐藏。</p>
<p>visibility:visible；元素可见。</p>
<p>visibility:hidden；元素隐藏。</p>
<p>visibility隐藏元素后，元素继续占有原来位置。</p>
<h3 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h3><p>overflow属性指定了如果内容溢出一个元素的框时，会发生什么。</p>
<p>属性值：</p>
<ul>
<li>visible，不剪切内容也不添加滚动条。</li>
<li>hidden，不显示超过尺寸的内容，超出的部分隐藏。</li>
<li>scroll，不管超出内容与否，总是显示滚动条。</li>
<li>auto，超出显示滚动条，不超出不显示。</li>
</ul>
<h2 id="精灵图"><a href="#精灵图" class="headerlink" title="精灵图"></a>精灵图</h2><p>主要借助于背景图位置实现：background-position。</p>
<p>一般情况下，坐标是负值。</p>
<h2 id="CSS三角"><a href="#CSS三角" class="headerlink" title="CSS三角"></a>CSS三角</h2><p>用一个div元素，宽高设置为0，设置边框粗细，样式，颜色，通过控制各边颜色透明与否，显示三角形样式。</p>
<h2 id="CSS用户界面样式"><a href="#CSS用户界面样式" class="headerlink" title="CSS用户界面样式"></a>CSS用户界面样式</h2><h3 id="鼠标样式cursor"><a href="#鼠标样式cursor" class="headerlink" title="鼠标样式cursor"></a>鼠标样式cursor</h3><p>通过cursor属性设置在对象上移动的鼠标采用什么光标形状。</p>
<p>属性值：</p>
<ul>
<li>default,默认，白色箭头。</li>
<li>pointer，小手。</li>
<li>move，移动。</li>
<li>text，文本。</li>
<li>not-allowed，禁止。</li>
</ul>
<h3 id="表单点击轮廓线outline"><a href="#表单点击轮廓线outline" class="headerlink" title="表单点击轮廓线outline"></a>表单点击轮廓线outline</h3><p>给表单设置outline:0或者outline：none后，可以去掉默认表单点击轮廓线。</p>
<h3 id="防止拖拽文本域resize"><a href="#防止拖拽文本域resize" class="headerlink" title="防止拖拽文本域resize"></a>防止拖拽文本域resize</h3><p>设置resize:none，防止拖拽文本域。此外文本域前后标签最好紧挨着。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>vertical-align属性用来给图片或表单（<strong>行内</strong>或<strong>行内块</strong>元素）设置和文字垂直对齐。</p>
<p>属性值：</p>
<p>![](E:\笔记\笔记图片\Screenshot 2023-01-11 114205.png)</p>
<h3 id="解决图片底部默认空白缝隙问题"><a href="#解决图片底部默认空白缝隙问题" class="headerlink" title="解决图片底部默认空白缝隙问题"></a>解决图片底部默认空白缝隙问题</h3><p>原因是行内块元素会和文字的基线对齐。</p>
<p>解决方法：</p>
<ul>
<li>给图片添加vertical-align：middle|top|bottom。</li>
<li>把图片转换为块级元素display:block，因为块级元素没有vertical-align属性，不会有基线对齐的方式。</li>
</ul>
<h2 id="单行文本溢出省略号显示"><a href="#单行文本溢出省略号显示" class="headerlink" title="单行文本溢出省略号显示"></a>单行文本溢出省略号显示</h2><figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//强制一行内显示文本</span><br><span class="hljs-attribute">white-space</span>:nowrap;（默认<span class="hljs-attribute">normal</span>自动换行）<br><span class="hljs-comment">//超出的部分隐藏</span><br><span class="hljs-attribute">overflow</span>:hidden;<br><span class="hljs-comment">//文字用省略号替代超出的部分</span><br><span class="hljs-attribute">text-overflow</span>:ellipsis;<br></code></pre></td></tr></table></figure>

<h2 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a>CSS3新特性</h2><h3 id="CSS3新增选择器"><a href="#CSS3新增选择器" class="headerlink" title="CSS3新增选择器"></a>CSS3新增选择器</h3><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><p>属性选择器可以根据元素特定属性来选择元素。</p>
<p> ![](E:\笔记\笔记图片\Screenshot 2023-01-11 203955.png)</p>
<p>属性选择器、类选择器、伪类选择器权重为10。</p>
<h4 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h4><p>结构伪类选择器主要根据文档结构来选择元素，常用于根据父级选择里面的子元素。</p>
<p>![](E:\笔记\笔记图片\Screenshot 2023-01-11 204914.png)</p>
<p>例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<br>	属性:属性值;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>nth-child(n)，n可以是数字，关键字（even偶数、odd奇数），公式。</p>
<p>常见公式（如果n是公式，则从0开始计算，但是第0个元素或者超出了元素的个数会被忽略，这里面只能是n，不能是其它字母）：</p>
<p>![](E:\笔记\笔记图片\Screenshot 2023-01-11 211312.png)</p>
<p>nth-child会把所有的盒子都排列序号。</p>
<p>执行的时候首先看:nth-child(n)，再看前面的元素。</p>
<p>nth-of-type会把指定元素的盒子排列序号。</p>
<p>执行的时候首先看前面的元素，再看:nth-child(n)。</p>
<h4 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h4><p>伪元素选择器是利用CSS创建新标签元素，而不需要HTML标签，从而简化HTML结构。</p>
<ul>
<li>::before，在元素内部的前面插入内容。</li>
<li>::after，在元素内部的后面插入内容。</li>
</ul>
<p>before和after创建一个元素，但是属于行内元素。</p>
<p>before和after必须有content属性。</p>
<p>伪元素选择器和标签选择器权重一样为1.</p>
<h3 id="CSS3盒子模型"><a href="#CSS3盒子模型" class="headerlink" title="CSS3盒子模型"></a>CSS3盒子模型</h3><p>CSS3可以通过box-sizing来指定盒模型，属性值：</p>
<ul>
<li>box-sizing:content-box，盒子大小为width+padding+border（默认）。</li>
<li>box-sizing:border-box，盒子大小为width。</li>
</ul>
<p>如果盒子模型选择box-sizing:border-box，那么padding和border就不会撑大盒子了（前提是padding和border不会超过width宽度）。</p>
<h3 id="CSS3滤镜filter"><a href="#CSS3滤镜filter" class="headerlink" title="CSS3滤镜filter"></a>CSS3滤镜filter</h3><p>filter属性将模糊或颜色偏移等图形效果应用于元素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">filter</span>: 函数();<br></code></pre></td></tr></table></figure>

<h3 id="CSS3calc函数"><a href="#CSS3calc函数" class="headerlink" title="CSS3calc函数"></a>CSS3calc函数</h3><p>calc函数可以在声明CSS属性值时执行一些计算。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">width</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100%</span>-<span class="hljs-number">30px</span>);<br></code></pre></td></tr></table></figure>

<h3 id="CSS3过渡"><a href="#CSS3过渡" class="headerlink" title="CSS3过渡"></a>CSS3过渡</h3><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transition</span>: 要过渡的属性 花费时间 运动时间 何时开始;<br></code></pre></td></tr></table></figure>

<p>要过渡的属性：想要变化的CSS属性，宽度、高度、颜色等。如果想要所有的属性都变化过渡，可以写all。</p>
<p>花费时间：单位是秒，必须写单位。</p>
<p>运动曲线：默认是ease（可以省略）。</p>
<p>何时开始：单位是秒（必须写单位），可以设置延迟触发时间，默认是0s（可以省略）。</p>
<p>过渡属性写在需要变化的元素上。</p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora使用方法总结</title>
    <url>/2022/07/01/Typora%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="一、基础方法"><a href="#一、基础方法" class="headerlink" title="一、基础方法"></a>一、基础方法</h1><h3 id="1-1标题"><a href="#1-1标题" class="headerlink" title="1.1标题"></a>1.1标题</h3><ul>
<li>使用快捷键Ctrl+1（2，3，4，5，6）表示相对应的标题（如HTML中的&lt;h1&gt;，&lt;h2&gt;等）。</li>
<li>Ctrl+0表示段落（如HTML中的&lt;p&gt;）。</li>
<li>此类快捷键信息可在菜单栏中的段落选项下查看。</li>
</ul>
<h3 id="1-2字体"><a href="#1-2字体" class="headerlink" title="1.2字体"></a>1.2字体</h3><ul>
<li>快捷键<code>Ctrl+I</code>来表示  <em>斜体文本</em></li>
<li>快捷键<code>Ctrl+B</code>来表示  <strong>粗体文本</strong></li>
</ul>
<h3 id="1-3各类线"><a href="#1-3各类线" class="headerlink" title="1.3各类线"></a>1.3各类线</h3><ul>
<li><p>以使用<strong>三个及以上</strong>的 <code>+</code>  来表示一条分割线：</p>
<hr>
</li>
<li><p><code>Alt+Shift+5</code>来表示   <del>删除文本</del></p>
</li>
<li><p>快捷键<code>Ctrl+U</code>来下划线  <u>下划线文本</u></p>
</li>
</ul>
<h3 id="1-4列表"><a href="#1-4列表" class="headerlink" title="1.4列表"></a>1.4列表</h3><ul>
<li>可以使用 * 标记符号来表示<strong>无序列表</strong>，注意要在标记符号后<strong>添加一个空格</strong></li>
<li>可以使用<strong>数字加上<code>.</code>再加上空格</strong>来表示<strong>有序列表</strong></li>
</ul>
<h3 id="1-5区块"><a href="#1-5区块" class="headerlink" title="1.5区块"></a>1.5区块</h3><ul>
<li>可以使用<code>&gt;</code>加空格来表示区块：</li>
</ul>
<blockquote>
<p>12312312</p>
</blockquote>
<h3 id="1-6代码"><a href="#1-6代码" class="headerlink" title="1.6代码"></a>1.6代码</h3><ul>
<li>如果是一行代码，可以使用段内代码块来表示，用一对 **&#96;**（数字1旁边的符号）括住代码。</li>
<li>如果是代码段,可以使用<strong>三个 &#96; 加Enter+编程语言</strong>来表示</li>
</ul>
<h3 id="1-7链接"><a href="#1-7链接" class="headerlink" title="1.7链接"></a>1.7链接</h3><ul>
<li><p>链接的使用方式有两种语法，如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">链接文字</span>](<span class="hljs-link">链接地址</span>)<br>或<br>&lt;链接地址&gt;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>例如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">百度</span>](<span class="hljs-link">https://www.baidu.com/</span>) <span class="language-xml">&lt;https://www.baidu.com/&gt;</span><br></code></pre></td></tr></table></figure>

<p><a href="https://www.baidu.com/">百度</a> <a href="https://www.baidu.com/">https://www.baidu.com/</a></p>
<ul>
<li>链接除了可以打开相应的网页外，还可以<strong>打开本地文件</strong></li>
<li>链接地址需要使用本地文件的地址，相对地址、绝对地址均可</li>
<li>相对地址的表示中：一个小圆点<code>.</code>表示当前目录，两个小圆点<code>..</code>表示上一级目录。</li>
<li>可以使用链接来实现<strong>页内跳转</strong>：</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">链接文字</span>](<span class="hljs-link">#标题文字</span>)<br></code></pre></td></tr></table></figure>

<p>注意CSDN不支持页面跳转。</p>
<h3 id="1-8图片"><a href="#1-8图片" class="headerlink" title="1.8图片"></a>1.8图片</h3><ul>
<li>可以在Markdown文档中插入图片：</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">alt 属性文本</span>](<span class="hljs-link">图片地址</span>) ![<span class="hljs-string">alt 属性文本</span>](<span class="hljs-link">图片地址 &quot;可选标题&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">网络图片</span>](<span class="hljs-link">http://static.runoob.com/images/runoob-logo.png &quot;菜鸟教程&quot;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="1-9表格"><a href="#1-9表格" class="headerlink" title="1.9表格"></a>1.9表格</h3><ul>
<li>可以使用快捷键<strong>Ctrl+T</strong>来插入表格</li>
</ul>
<h2 id="二、扩展方法"><a href="#二、扩展方法" class="headerlink" title="二、扩展方法"></a>二、扩展方法</h2><h3 id="2-1字体颜色及大小"><a href="#2-1字体颜色及大小" class="headerlink" title="2.1字体颜色及大小"></a>2.1字体颜色及大小</h3><ul>
<li>可以使用<code>&lt;font&gt; &lt;/font&gt;</code>标签来改变字体的颜色及大小 如：</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">size</span>=<span class="hljs-string">3</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span></span>字体颜色为红色，大小为3<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<ul>
<li>其中<code>size</code>表示字体大小，<code>color</code>表示颜色</li>
</ul>
<h3 id="2-2对齐方式"><a href="#2-2对齐方式" class="headerlink" title="2.2对齐方式"></a>2.2对齐方式</h3><ul>
<li>可以改变字体的对齐方式，用标签<code>&lt;p&gt; &lt;/p&gt;</code>加上属性<code>align</code>，如：</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span></span>左对齐<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span></span>中间对齐<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span></span>右对齐<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><ul>
<li>上述方法仅为部分常用方法。</li>
<li>参考资料：[1] 菜鸟Markdown教程：<a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></li>
</ul>
]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/2023/04/11/HTML/</url>
    <content><![CDATA[<h2 id="基本标签"><a href="#基本标签" class="headerlink" title="基本标签"></a>基本标签</h2><p>HTML的基本骨架：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="lt-DOCTYPE-gt-标签"><a href="#lt-DOCTYPE-gt-标签" class="headerlink" title="&lt;!DOCTYPE&gt;标签"></a>&lt;!DOCTYPE&gt;标签</h2><!DOCTYPE><p>文档类型声明标签（注意不是HTML标签），用于告诉浏览器使用的是哪种版本的HTML来显示网页。</p>
<p><code>&lt;!DOCTYPE html&gt;</code>表明当前页面采取的是HTML5版本来显示网页。</p>
<h2 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h2><p>HTML标签，页面中最大的标签，作为文档的<strong>根标签</strong>。</p>
<p>存在属性lang，表示文档的语言，支持的值主要为”en”：英语；”zh-CN”：中文……</p>
<h2 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h2><p>meta表示“元”，即基本的配置项目。</p>
<p><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>用来规定HTML文档使用的字符编码，utf-8是目前最常用的字符集编码方式，</p>
<h2 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h2><p><code>&lt;h1&gt; - &lt;h6&gt;</code>，一个标题独占一行。</p>
<h2 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h2><p><code>&lt;p&gt;</code>段落标签。文本在一个段落中会根据浏览器窗口大小自动换行。段落和段落之间会存在空隙。</p>
<h2 id="换行标签"><a href="#换行标签" class="headerlink" title="换行标签"></a>换行标签</h2><p><code>&lt;br/&gt;</code>（单标签）</p>
<h2 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h2><p>文字加粗：<code>&lt;strong&gt;</code>或<code>&lt;b&gt;</code></p>
<p>文字倾斜：<code>&lt;em&gt;</code>或<code>&lt;i&gt;</code></p>
<p>删除线：<code>&lt;del&gt;</code>或<code>&lt;s&gt;</code></p>
<p>下划线：<code>&lt;ins&gt;</code>或<code>&lt;u&gt;</code></p>
<h2 id="lt-div-gt-和-lt-span-gt-标签"><a href="#lt-div-gt-和-lt-span-gt-标签" class="headerlink" title="&lt;div&gt;和&lt;span&gt;标签"></a>&lt;div&gt;和&lt;span&gt;标签</h2><p>没有语义，代表一个盒子用来装内容。</p>
<p><code>&lt;div&gt;</code>可以理解为一个大盒子，一行只能放一个。</p>
<p><code>&lt;span&gt;</code>可以理解为一个小盒子，一行可以放很多个。</p>
<h2 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h2><p><code>&lt;img src=&quot;图片URL&quot; /&gt;</code></p>
<p>图像标签的属性：</p>
<ul>
<li>src是<code>&lt;img&gt;</code>标签的的必须属性，用于指定图像文件的路径和文件名。</li>
<li>alt，替换文本，图片不能显示时显示的文字。</li>
<li>title，提示文本，鼠标放到图像上，显示的文字。</li>
<li>width，设置图像的宽度，单位px可以不写。</li>
<li>height，设置图像的高度，单位px可以不写。（width和height可以只修改一个，另一个会等比例缩放）</li>
<li>border，设置图像的边框粗细，单位px可以不写。</li>
</ul>
<h2 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h2><p><code>&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt;</code></p>
<p><code>&lt;a&gt;</code>标签用于定义超链接，作用是从一个页面链接到另一个页面。</p>
<p>链接分类：</p>
<ul>
<li>外部链接：例如<code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;</code>。</li>
<li>内部链接：网站内部页面之间的相互链接，直接链接内部页面名称即可。例如：<code>&lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt;</code>。</li>
<li>空链接：如果当时没有确定链接目标，例如：<code>&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;</code>。</li>
<li>下载链接：如果href里面地址是一个文件（.exe）或压缩包（.zip），会下载这个文件。</li>
<li>网页元素链接：在网页中的各种网页元素，如文本、图像、视频、表格、音频等都可以添加超链接。</li>
<li>锚点链接：当我们点击链接，可以快速定位到页面中的某个位置。使用方法：</li>
</ul>
<ol>
<li>在链接文本的href属性中，设置属性值为<code>#名字</code>的形式，如：<code>&lt;a href=&quot;#first&quot;&gt;第一点&lt;/a&gt;</code>。</li>
<li>找到目标位置标签，里面添加一个<code>id属性=刚才的名字</code>，如：<code>&lt;h1 id=&quot;first&quot;&gt;第一点介绍&lt;/h1&gt;</code>。</li>
</ol>
<p>超链接标签的属性：</p>
<ul>
<li>href，必须属性，用于指定链接目标的url地址。</li>
<li>target，用于指定链接页面的的打开方式，其中_self为默认值，表示当前窗口打开页面，__blank为在新窗口中打开页面。</li>
</ul>
<h2 id="注释标签"><a href="#注释标签" class="headerlink" title="注释标签"></a>注释标签</h2><p><code>&lt;!--注释语句--&gt;</code>，注释语句便于阅读和理解，不在页面中显示。</p>
<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>在HTML页面中，一些特殊的符号很难或者不方便直接使用，此时我们就可以使用下面的字符来代替：</p>
<ul>
<li><code>&amp;nbsp;</code>表示空格。</li>
<li><code>&amp;lt;</code>表示 &lt; 符号。</li>
<li><code>&amp;gt;</code>表示 &gt; 符号。</li>
</ul>
<h2 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h2><h3 id="基本标签-1"><a href="#基本标签-1" class="headerlink" title="基本标签"></a>基本标签</h3><p>表格主要用于展示数据。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;table&gt;</span><br>        <span class="hljs-section">&lt;tr&gt;</span><br>            <span class="hljs-section">&lt;td&gt;</span><span class="hljs-section">&lt;/td&gt;</span><br>        <span class="hljs-section">&lt;/tr&gt;</span><br><span class="hljs-section">&lt;/table&gt;</span><br></code></pre></td></tr></table></figure>

<p><code>&lt;table&gt;</code>是用于定义表格的标签。</p>
<p><code>&lt;tr&gt;</code>用于定义表格中的行，必须嵌套在<code>&lt;table&gt;</code>中。</p>
<p><code>&lt;td&gt;</code>是用于定义表格中的单元格，必须嵌套在<code>&lt;tr&gt;</code>中。</p>
<h3 id="表头单元格标签"><a href="#表头单元格标签" class="headerlink" title="表头单元格标签"></a>表头单元格标签</h3><p>一般表头单元格位于表格的第一行或第一列，表头单元格的文本内容加粗居中显示。</p>
<p><code>&lt;th&gt;</code>标签表示HTML表格的表头部分。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;table&gt;</span><br>        <span class="hljs-section">&lt;tr&gt;</span><br>            <span class="hljs-section">&lt;th&gt;</span><span class="hljs-section">&lt;/th&gt;</span><br>        <span class="hljs-section">&lt;/tr&gt;</span><br><span class="hljs-section">&lt;/table&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h3><ul>
<li>align：left、center、right。规定表格相对周围元素的对齐方式（注意是整个表格的位置）。</li>
<li>border：””或像素值。规定表格单元是否拥有边框，默认为””，表示没有边框。</li>
<li>cellpadding：像素值。规定单元边沿与其内容之间的空白，默认为1像素。</li>
<li>cellspacing：像素值。规定单元格之间的空白，默认为2像素。</li>
<li>width：像素值或百分比。规定表格的宽度。</li>
<li>height:像素值或百分比。规定表格的高度。</li>
</ul>
<h3 id="表格结构标签"><a href="#表格结构标签" class="headerlink" title="表格结构标签"></a>表格结构标签</h3><p>表格标签<code>&lt;thead&gt;</code>，<code>&lt;tbody&gt;</code>可以更好地分清表格结构。</p>
<ul>
<li><code>&lt;thead&gt;</code>表示表格的头部区域。</li>
<li><code>&lt;tbody&gt;</code>表示表格的主体区域。</li>
</ul>
<h3 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h3><p>合并单元格方式：</p>
<ul>
<li>跨行合并：rowspan&#x3D;”合并单元格个数”。</li>
<li>跨列合并：colspan&#x3D;”合并单元格个数”。</li>
</ul>
<p>目标单元格（写合并代码）：</p>
<ul>
<li>跨行：最上侧的单元格为目标单元格，在此单元格上写合并代码。</li>
<li>跨列：最左侧的单元格为目标单元格，在此单元格上写合并代码。</li>
</ul>
<h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><p>表格是用来展示数据的，那么列表就是用来布局的。</p>
<p>列表分为：无序列表，有序列表、自定义列表。</p>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p><code>&lt;ul&gt;</code>标签表示HTML页面中的无序列表。</p>
<p><code>&lt;li&gt;</code>标签表示无序列表<code>&lt;ul&gt;</code>标签中的列表项，列表项前存在项目符号圆点。</p>
<p><code>&lt;ul&gt;</code>中只能嵌套<code>&lt;li&gt;</code>，直接在<code>&lt;ul&gt;</code>中输入其它标签或文字是不被允许的。	</p>
<p><code>&lt;li&gt;</code>相当于一个容器，可以容纳其它元素。</p>
<p>无序列表会自带css属性，可以通过CSS设置list-style:none去掉。</p>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表即为有排列顺序的列表，其各个列表项会按照一定的顺序排列定义。</p>
<p><code>&lt;ol&gt;</code>标签用于定义有序列表，列表排序以数字来显示。</p>
<p><code>&lt;li&gt;</code>标签用于定义列表项，列表项前存在项目符号有序数字。</p>
<p><code>&lt;ol&gt;</code>中只能嵌套<code>&lt;li&gt;</code>，直接在<code>&lt;ul&gt;</code>中输入其它标签或文字是不被允许的。	</p>
<p><code>&lt;li&gt;</code>相当于一个容器，可以容纳其它元素。</p>
<p>有序列表会自带css属性，可以通过CSS设置。</p>
<h3 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h3><p>自定义列表常用于对术语或名词进行解释和描述。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>名词<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>解释一<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>解释二<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><code>&lt;dl&gt;</code>标签用于定义描述列表。</p>
<p><code>&lt;dt&gt;</code>标签用于定义项目&#x2F;名字。</p>
<p><code>&lt;dd&gt;</code>标签用于描述项目&#x2F;名字。</p>
<p><code>&lt;dl&gt;</code>中只能包含<code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code>。</p>
<p><code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code>中可以放其它标签。</p>
<h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h2><p>一个完整的表单通常由表单域、表单控件（也称表单元素）和提示信息3个部分构成。</p>
<h3 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h3><p>表单域是一个包含表单元素的区域。</p>
<p><code>&lt;form&gt;</code>标签用于定义表单域，以实现用户信息的收集和传递。<code>&lt;form&gt;</code>会把它范围内的表单元素信息提交给服务器。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">&lt;form action<span class="hljs-operator">=</span><span class="hljs-string">&quot;url地址&quot;</span> method<span class="hljs-operator">=</span><span class="hljs-string">&quot;提交方式&quot;</span> name<span class="hljs-operator">=</span><span class="hljs-string">&quot;表单域名称&quot;</span>&gt;<br>        各种表单元素控件<br>&lt;/form&gt;<br></code></pre></td></tr></table></figure>

<p>属性：</p>
<ul>
<li>action：url地址。用于指定接收并处理表单数据的服务器的url地址。</li>
<li>method：get&#x2F;post。用于设置表单数据的提交方式，其取值为get&#x2F;post。</li>
<li>name：名称。用于指定表单的名称，以区分同一个页面中的多个表单域。</li>
</ul>
<h3 id="表单控件（表单元素）"><a href="#表单控件（表单元素）" class="headerlink" title="表单控件（表单元素）"></a>表单控件（表单元素）</h3><ol>
<li>input输入表单元素。</li>
<li>select下拉表单元素。</li>
<li>textarea文本域元素。</li>
</ol>
<h4 id="lt-input-gt-表单元素"><a href="#lt-input-gt-表单元素" class="headerlink" title="&lt;input&gt;表单元素"></a><code>&lt;input&gt;</code>表单元素</h4><p><code>&lt;input&gt;</code>标签用于收集用户信息。</p>
<p>在<code>&lt;input&gt;</code>标签中有一个type属性，根据不同的type属性值，输入字段拥有很多种形式。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;属性值&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>&lt;input&gt;</code>标签为单标签。</li>
<li>type属性设置不同的属性值来指定不同的控件类型:</li>
</ul>
<p>![](E:\笔记\笔记图片\Screenshot 2022-12-18 121332.png)</p>
<p><code>&lt;input&gt;</code>中还有其他属性：</p>
<ul>
<li>name：属性值自定义。定义input元素的名称，注意radio单选按钮和checkbox复选框中name属性应相同，特别是在单选按钮中，只有name属性值相同，才能实现多选一效果。</li>
<li>value：属性值自定义。规定input元素的值，会在文本框中显示，单选按钮和复选框中不会显示。</li>
<li>checked：属性值为checked或者省略。主要针对单选按钮和复选框，规定此input元素首次加载时应当被选中。</li>
<li>maxlength:正整数。规定此输入字段中的字符的最大长度。</li>
</ul>
<h5 id="lt-label-gt-标签"><a href="#lt-label-gt-标签" class="headerlink" title="&lt;label&gt;标签"></a><code>&lt;label&gt;</code>标签</h5><p><code>&lt;label&gt;</code>标签为input元素定义标注（标签）。</p>
<p><code>&lt;label&gt;</code>标签用于绑定一个表单元素，当点击<code>&lt;label&gt;</code>标签内的文本时，浏览器就会自动将焦点（光标）转到或者选择对应的表单元素上，用来增加用户体验。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;label <span class="hljs-attribute">for</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;男&lt;/label&gt;<br>&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;sex&quot;</span> &gt;<br></code></pre></td></tr></table></figure>

<p><code>&lt;label&gt;</code>标签的for属性应当与相关元素的id属性相同。</p>
<h3 id="lt-select-gt-表单元素"><a href="#lt-select-gt-表单元素" class="headerlink" title="&lt;select&gt;表单元素"></a><code>&lt;select&gt;</code>表单元素</h3><p>在页面，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用<code>&lt;select&gt;</code>标签控件定义下拉列表。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> &gt;</span>****<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> &gt;</span>****<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> &gt;</span>****<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><code>&lt;select&gt;</code>中至少包含一对<code>&lt;option&gt;</code>。</p>
<p>在<code>&lt;option&gt;</code>中定义selected属性时，当前项即为默认选中项。</p>
<h3 id="lt-textarea-gt-表单元素"><a href="#lt-textarea-gt-表单元素" class="headerlink" title="&lt;textarea&gt;表单元素"></a><code>&lt;textarea&gt;</code>表单元素</h3><p>当用户输入内容较多情况下，就不能使用文本框表单了，此时可以使用<code>&lt;textarea&gt;</code>标签。</p>
<p><code>&lt;textarea&gt;</code>标签是用于定义多行文本输入的控件。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;textarea <span class="hljs-attribute">cols</span>=<span class="hljs-string">&quot;每行中的字符数&quot;</span> <span class="hljs-attribute">rows</span>=<span class="hljs-string">&quot;显示的行数&quot;</span>&gt;&lt;/textarea&gt;<br></code></pre></td></tr></table></figure>

<p>存在cols和rows属性。</p>
<h2 id="HTML5部分新特性"><a href="#HTML5部分新特性" class="headerlink" title="HTML5部分新特性"></a>HTML5部分新特性</h2><h3 id="HTML5新增的语义化标签"><a href="#HTML5新增的语义化标签" class="headerlink" title="HTML5新增的语义化标签"></a>HTML5新增的语义化标签</h3><ul>
<li>&lt;header&gt;头部标签</li>
<li>&lt;nav&gt;导航标签</li>
<li>&lt;article&gt;内容标签</li>
<li>&lt;section&gt;定义文档某个区域</li>
<li>&lt;aside&gt;侧边栏标签</li>
<li>&lt;footer&gt;尾部标签</li>
</ul>
<h3 id="HTML5新增的多媒体标签"><a href="#HTML5新增的多媒体标签" class="headerlink" title="HTML5新增的多媒体标签"></a>HTML5新增的多媒体标签</h3><h4 id="lt-video-gt-视频"><a href="#lt-video-gt-视频" class="headerlink" title="&lt;video&gt;视频"></a>&lt;video&gt;视频</h4><p>&lt;video&gt;支持三种视频格式（mp4,webm,ogg），mp4兼容性更好。</p>
<p>属性：</p>
<p>![](E:\笔记\笔记图片\Screenshot 2023-01-11 142712.png)</p>
<h4 id="lt-audio-gt-音频"><a href="#lt-audio-gt-音频" class="headerlink" title="&lt;audio&gt;音频"></a>&lt;audio&gt;音频</h4><p>&lt;audio&gt;支持三种音频格式（mp3,wav,ogg），mp3兼容性更好。</p>
<p>![](E:\笔记\笔记图片\Screenshot 2023-01-11 143127.png) </p>
<p>谷歌浏览器把视频和音频自动播放禁止了。</p>
<h3 id="HTML5新增的input类型"><a href="#HTML5新增的input类型" class="headerlink" title="HTML5新增的input类型"></a>HTML5新增的input类型</h3><p>![](E:\笔记\笔记图片\Screenshot 2023-01-11 201438.png)</p>
<h3 id="HTML5新增的表单属性"><a href="#HTML5新增的表单属性" class="headerlink" title="HTML5新增的表单属性"></a>HTML5新增的表单属性</h3><p>![](E:\笔记\笔记图片\Screenshot 2023-01-11 202147.png)</p>
<p>可以通过：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">::placeholder</span> &#123;<br>	<span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>修改placeholder里的字体颜色。</p>
]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>从0到1实现H5游戏</title>
    <url>/2022/07/19/%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0H5%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="从0到1实现H5游戏"><a href="#从0到1实现H5游戏" class="headerlink" title="从0到1实现H5游戏"></a>从0到1实现H5游戏</h1><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p><a href="https://yeatsczx.github.io/html/game.html">试玩地址</a></p>
<p><a href="https://github.com/Yeatsczx/H5game">源码</a></p>
<p><img src="https://img-blog.csdnimg.cn/33d423652af54cc2baf930ce283f322e.png#pic_center"></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我将这款游戏命名为herald（先驱），玩家可以在界面右上角改变操控模式（鼠键模式和声音模式），通过鼠标点击、空格键、↑键以及声音控制herald（herald即移动的黑色小方块，以下皆由herald代指黑色小方块）跳动，herald可连续跳动两次，第三次herald会加速坠落，herald的速度会随着时间的变化而慢慢加快。当herald消失于地面两个平台之间的间隙时或者触碰到地面任意平台左侧时，游戏结束并且游戏会自动重新开始。在开发过程中，有借鉴各路实现。</p>
<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>HTML+CSS+JavaScript,其中运用了H5中的canvas。</p>
<h2 id="开发思路"><a href="#开发思路" class="headerlink" title="开发思路"></a>开发思路</h2><h3 id="Rect-矩形"><a href="#Rect-矩形" class="headerlink" title="Rect(矩形)"></a>Rect(矩形)</h3><p>此部分主要为绘制矩形，包括herald和地面平台，此外还包括判断herald和地面平台是否相交。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">class Rect &#123;<br>  constructor(<span class="hljs-built_in">props</span>) &#123;<br>    //画矩形<br>    this.<span class="hljs-built_in">draw</span> = (&#123; ctx &#125;) =&gt; &#123;<br>      ctx.<span class="hljs-built_in">save</span>();<br>      ctx.globalAlpha = this.<span class="hljs-built_in">opacity</span>;<br>      ctx.fillStyle = this.<span class="hljs-built_in">color</span>;<br>      ctx.fillRect(this.<span class="hljs-built_in">position</span>.x, this.<span class="hljs-built_in">position</span>.y, this.<span class="hljs-built_in">width</span>, this.<span class="hljs-built_in">height</span>);<br>      ctx.restore();<br>    &#125;;<br>    this.<span class="hljs-built_in">position</span> = <span class="hljs-built_in">props</span>.<span class="hljs-built_in">position</span>;<br>    this.<span class="hljs-built_in">width</span> = <span class="hljs-built_in">props</span>.<span class="hljs-built_in">width</span>;<br>    this.<span class="hljs-built_in">height</span> = <span class="hljs-built_in">props</span>.<span class="hljs-built_in">height</span>;<br>    this.<span class="hljs-built_in">color</span> = <span class="hljs-built_in">props</span>.<span class="hljs-built_in">color</span>;<br>    this.<span class="hljs-built_in">opacity</span> = <span class="hljs-built_in">props</span>.<span class="hljs-built_in">opacity</span> ?? <span class="hljs-number">1</span>;<br>  &#125;<br>  // 判断两个矩形是否相交，r1为herald，列举四种不相交的情况，然后取反<br>  static isIntersect(r1, r2) &#123;<br>    <span class="hljs-built_in">return</span> !(r2.<span class="hljs-built_in">position</span>.x &gt; r1.<span class="hljs-built_in">position</span>.x + r1.<span class="hljs-built_in">width</span> ||<br>      r2.<span class="hljs-built_in">position</span>.x + r2.<span class="hljs-built_in">width</span> &lt; r1.<span class="hljs-built_in">position</span>.x ||<br>      r2.<span class="hljs-built_in">position</span>.y &gt; r1.<span class="hljs-built_in">position</span>.y + r1.<span class="hljs-built_in">height</span> ||<br>      r2.<span class="hljs-built_in">position</span>.y + r2.<span class="hljs-built_in">height</span> &lt; r1.<span class="hljs-built_in">position</span>.y);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Vector（向量）"><a href="#Vector（向量）" class="headerlink" title="Vector（向量）"></a>Vector（向量）</h3><p>此部分主要为一些操作向量的方法，向量可以表示速度，加速度，力。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vector</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">this</span>.x = x;<br>    <span class="hljs-keyword">this</span>.y = y;<br>  &#125;<br>  static add(vector1, vector2) &#123;<br>    <span class="hljs-keyword">return</span> new Vector(vector1.x + vector2.x, vector1.y + vector2.y);<br>  &#125;<br>  static sub(vector1, vector2) &#123;<br>    <span class="hljs-keyword">return</span> new Vector(vector1.x - vector2.x, vector1.y - vector2.y);<br>  &#125;<br>  static clone(vector) &#123;<br>    <span class="hljs-keyword">return</span> new Vector(vector.x, vector.y);<br>  &#125;<br>  static fromAngle(theta, d) &#123;<br>    <span class="hljs-keyword">return</span> new Vector(d * Math.cos(theta), d * Math.sin(theta));<br>  &#125;<br>  clone() &#123;<br>    <span class="hljs-keyword">return</span> new Vector(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y);<br>  &#125;<br>  add(vector) &#123;<br>    <span class="hljs-keyword">this</span>.x += vector.x;<br>    <span class="hljs-keyword">this</span>.y += vector.y;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>  &#125;<br>  sub(vector) &#123;<br>    <span class="hljs-keyword">this</span>.x -= vector.x;<br>    <span class="hljs-keyword">this</span>.y -= vector.y;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>  &#125;<br>  mult(scale) &#123;<br>    <span class="hljs-keyword">this</span>.x *= scale;<br>    <span class="hljs-keyword">this</span>.y *= scale;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>  &#125;<br>  div(scale) &#123;<br>    <span class="hljs-keyword">this</span>.x /= scale;<br>    <span class="hljs-keyword">this</span>.y /= scale;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>  &#125;<br>  <span class="hljs-comment">//计算向量的长度</span><br>  mag() &#123;<br>    <span class="hljs-keyword">return</span> Math.sqrt(<span class="hljs-keyword">this</span>.x * <span class="hljs-keyword">this</span>.x + <span class="hljs-keyword">this</span>.y * <span class="hljs-keyword">this</span>.y);<br>  &#125;<br>  <span class="hljs-comment">//求单位向量</span><br>  normalize() &#123;<br>    let m = <span class="hljs-keyword">this</span>.mag();<br>    <span class="hljs-keyword">if</span> (m !== <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">this</span>.div(m);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Stage（舞台）"><a href="#Stage（舞台）" class="headerlink" title="Stage（舞台）"></a><strong>Stage</strong>（舞台）</h3><p>此部分主要为请求动画帧，更新herald及平台数据并重新绘制herald和平台，还包括了做适配，消除图片边缘模糊现象，并将画布大小设置为整个浏览器窗口视图大小。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stage</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(props) &#123;<br>    <span class="hljs-keyword">var</span> _a;<br>    <span class="hljs-keyword">this</span>.entities = [];<br>    <span class="hljs-comment">//处理调整</span><br>    <span class="hljs-keyword">this</span>.handleResize = () =&gt; &#123;<br>      <span class="hljs-keyword">this</span>.<span class="hljs-keyword">init</span>();<br>    &#125;;<br>    <span class="hljs-keyword">this</span>.tick = (callback) =&gt; &#123;<br>      <span class="hljs-comment">//请求动画帧</span><br>      <span class="hljs-keyword">this</span>.raf = requestAnimationFrame(() =&gt; &#123;<br>        <span class="hljs-keyword">this</span>.ctx.clearRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.width, <span class="hljs-keyword">this</span>.height);<span class="hljs-comment">//擦除上一帧画布</span><br>        <span class="hljs-keyword">this</span>.tick(callback);<br>      &#125;);<br>      <span class="hljs-keyword">const</span> stage = &#123;<br>        width: <span class="hljs-keyword">this</span>.width,<br>        height: <span class="hljs-keyword">this</span>.height,<br>        verticalAcceleration: <span class="hljs-keyword">this</span>.verticalAcceleration,<br>        ctx: <span class="hljs-keyword">this</span>.ctx,<br>        horizontalVelocity: <span class="hljs-keyword">this</span>.horizontalVelocity<br>      &#125;;<br>      <span class="hljs-comment">//更新herald及平台数据</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entity of <span class="hljs-keyword">this</span>.entities) &#123;<br>        entity.update(stage);<br>      &#125;<br>      callback();<br>      <span class="hljs-comment">//重新绘制herald及平台</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entity of <span class="hljs-keyword">this</span>.entities) &#123;<br>        entity.draw(stage);<br>      &#125;<br>      <span class="hljs-keyword">this</span>.horizontalVelocity.add(<span class="hljs-keyword">this</span>.horizontalAcceleration);<br>    &#125;;<br>    <span class="hljs-keyword">this</span>.play = (callback) =&gt; &#123;<br>      <span class="hljs-keyword">this</span>.stop();<br>      <span class="hljs-keyword">this</span>.tick(callback);<br>    &#125;;<br>    <span class="hljs-comment">//取消请求动画帧</span><br>    <span class="hljs-keyword">this</span>.stop = () =&gt; &#123;<br>      cancelAnimationFrame(<span class="hljs-keyword">this</span>.raf);<br>    &#125;;<br>    <span class="hljs-keyword">this</span>.add = (...entity) =&gt; &#123;<br>      <span class="hljs-comment">//entity.length为2</span><br>      <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; entity.length; i++) &#123;<br>        <span class="hljs-keyword">this</span>.entities.push(entity[i]);<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">this</span>.reset = () =&gt; &#123;<br>      <span class="hljs-keyword">this</span>.horizontalVelocity = <span class="hljs-keyword">this</span>.initialHorizontalVelocity.clone();<br>      <span class="hljs-keyword">this</span>.entities = [];<br>    &#125;;<br>    <span class="hljs-keyword">this</span>.ele = document.getElementById(<span class="hljs-string">&quot;canvas&quot;</span>);<br>    <span class="hljs-keyword">this</span>.<span class="hljs-keyword">init</span>();<br>    <span class="hljs-keyword">this</span>.ctx = <span class="hljs-keyword">this</span>.ele.getContext(<span class="hljs-string">&quot;2d&quot;</span>);<br>    <span class="hljs-keyword">this</span>.verticalAcceleration = props.verticalAcceleration;<span class="hljs-comment">//重力加速度</span><br>    <span class="hljs-keyword">this</span>.initialHorizontalVelocity = props.initialHorizontalVelocity;<span class="hljs-comment">//初始水平速度</span><br>    <span class="hljs-keyword">this</span>.horizontalVelocity = props.initialHorizontalVelocity.clone();<br>    <span class="hljs-keyword">this</span>.horizontalAcceleration = props.horizontalAcceleration;<span class="hljs-comment">//水平加速度</span><br>    <span class="hljs-comment">//视图大小调整事件监听</span><br>    window.addEventListener(<span class="hljs-string">&quot;resize&quot;</span>, <span class="hljs-keyword">this</span>.handleResize, <span class="hljs-literal">false</span>);<br>  &#125;<br>  <span class="hljs-comment">//做适配，消除图片边缘模糊现象，并将画布大小设置为整个浏览器窗口视图大小</span><br>  <span class="hljs-keyword">init</span>() &#123;<br>    <span class="hljs-keyword">const</span> &#123; devicePixelRatio, innerWidth, innerHeight &#125; = window;<br>    <span class="hljs-keyword">this</span>.ele.width = innerWidth * devicePixelRatio;<br>    <span class="hljs-keyword">this</span>.ele.height = innerHeight * devicePixelRatio;<br>    <span class="hljs-keyword">this</span>.width = innerWidth;<br>    <span class="hljs-keyword">this</span>.height = innerHeight;<br>    <span class="hljs-keyword">this</span>.ele.style.width = <span class="hljs-keyword">this</span>.width + <span class="hljs-string">&quot;px&quot;</span>;<br>    <span class="hljs-keyword">this</span>.ele.style.height = <span class="hljs-keyword">this</span>.height + <span class="hljs-string">&quot;px&quot;</span>;<br>    <span class="hljs-keyword">this</span>.ctx = <span class="hljs-keyword">this</span>.ele.getContext(<span class="hljs-string">&quot;2d&quot;</span>);<br>    <span class="hljs-comment">//为 canvas 单位添加缩放变换</span><br>    <span class="hljs-keyword">this</span>.ctx.scale(devicePixelRatio, devicePixelRatio);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Platform（平台）"><a href="#Platform（平台）" class="headerlink" title="Platform（平台）"></a><strong>Platform</strong>（平台）</h3><p>此部分主要为更新平台位置</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Platform</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rect</span> </span>&#123;<br>    update(stage) &#123;<br>        const &#123; horizontalVelocity &#125; = stage;<br>        <span class="hljs-keyword">this</span>.prevPosition = <span class="hljs-keyword">this</span>.position.clone();<br>        <span class="hljs-keyword">this</span>.position.add(horizontalVelocity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Particle-粒子"><a href="#Particle-粒子" class="headerlink" title="Particle(粒子)"></a>Particle(粒子)</h3><p>此部分主要为实现粒子效果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Particle</span> <span class="hljs-title">extends</span> <span class="hljs-title">Rect</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span>(props) &#123;<br>        <span class="hljs-keyword">super</span>(props);<br>        <span class="hljs-keyword">this</span>.applyForce = (force) =&gt; &#123;<br>            <span class="hljs-keyword">this</span>.velocity.add(force.clone().div(<span class="hljs-keyword">this</span>.mass));<br>        &#125;;<br>        <span class="hljs-keyword">this</span>.update = (stage) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isFirstTime) &#123;<br>                <span class="hljs-keyword">this</span>.opacity -= <span class="hljs-number">0.05</span>;<span class="hljs-comment">//让粒子慢慢消失</span><br>                <span class="hljs-keyword">const</span> &#123; verticalAcceleration, horizontalVelocity &#125; = stage;<br>                <span class="hljs-keyword">this</span>.velocity.add(verticalAcceleration);<br>                <span class="hljs-keyword">this</span>.position.add(Vector.add(<span class="hljs-keyword">this</span>.velocity, horizontalVelocity));<br>                <span class="hljs-keyword">this</span>.opacity = Math.max(<span class="hljs-keyword">this</span>.opacity, <span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-keyword">this</span>.isFirstTime = <span class="hljs-literal">false</span>;<br>        &#125;;<br>        <span class="hljs-keyword">this</span>.velocity = props.velocity;<br>        <span class="hljs-keyword">this</span>.isFirstTime = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">this</span>.mass = props.mass;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Herald-先驱"><a href="#Herald-先驱" class="headerlink" title="Herald(先驱)"></a>Herald(先驱)</h3><p>此部分主要实现herald的跳跃行为并更新herald数据。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Herald</span> <span class="hljs-title">extends</span> <span class="hljs-title">Rect</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span>(props) &#123;<br>        <span class="hljs-keyword">super</span>(props);<br>        <span class="hljs-keyword">this</span>.applyForce = (force) =&gt; &#123;<br>            <span class="hljs-keyword">this</span>.velocity.add(force.clone().div(<span class="hljs-keyword">this</span>.mass));<span class="hljs-comment">//this.mass应该为一个倍数值。</span><br>        &#125;;<br>        <span class="hljs-comment">//herald跳跃行为</span><br>        <span class="hljs-keyword">this</span>.jump = () =&gt; &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.curConJump &lt; <span class="hljs-keyword">this</span>.maxConJump) &#123;<br>                <span class="hljs-comment">//velocity为给一个速度</span><br>                <span class="hljs-keyword">this</span>.velocity = new Vector();<span class="hljs-comment">//将this.velocity重置为（0,0），如果不做这一步，herald的速度可能已经向下了，甚至可能大于后面所给的一个向下的速度，就有可能跳第二次herald没什么反应了。</span><br>                <span class="hljs-keyword">this</span>.applyForce === <span class="hljs-literal">null</span> || <span class="hljs-keyword">this</span>.applyForce === void <span class="hljs-number">0</span> ? void <span class="hljs-number">0</span> : <span class="hljs-keyword">this</span>.applyForce(new Vector(<span class="hljs-number">0</span>, -<span class="hljs-number">12</span>));<br>                <span class="hljs-keyword">this</span>.curConJump++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.curConJump === <span class="hljs-keyword">this</span>.maxConJump) &#123;<br>                <span class="hljs-keyword">this</span>.velocity.add(new Vector(<span class="hljs-number">0</span>, <span class="hljs-number">30</span>));<br>                <span class="hljs-keyword">this</span>.curConJump++;<span class="hljs-comment">//在碰撞时this.curConJump会为0</span><br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">this</span>.mass = props.mass !== <span class="hljs-literal">null</span> &amp;&amp; props.mass !== void <span class="hljs-number">0</span> ? props.mass : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">this</span>.velocity = props.velocity !== <span class="hljs-literal">null</span> &amp;&amp; props.velocity !== void <span class="hljs-number">0</span> ? props.velocity : new Vector();<br>        <span class="hljs-keyword">this</span>.maxConJump = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">this</span>.curConJump = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//更新herald数据</span><br>    update(stage) &#123;<br>        <span class="hljs-keyword">const</span> &#123; verticalAcceleration &#125; = stage;<br>        <span class="hljs-keyword">this</span>.prevPosition = <span class="hljs-keyword">this</span>.position.clone();<br>        <span class="hljs-keyword">this</span>.prevVelocity = <span class="hljs-keyword">this</span>.velocity.clone();<br>        <span class="hljs-keyword">this</span>.velocity.add(verticalAcceleration);<br>        <span class="hljs-comment">//sub 左参数-右参数</span><br>        <span class="hljs-keyword">this</span>.position.add(Vector.sub(<span class="hljs-keyword">this</span>.velocity, verticalAcceleration.clone().mult(<span class="hljs-number">0.5</span>)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="PlatformManager（平台管理者）"><a href="#PlatformManager（平台管理者）" class="headerlink" title="PlatformManager（平台管理者）"></a>PlatformManager（平台管理者）</h3><p>此部分主要为创建平台随机数据并绘制平台，此外实现了无限循环的障碍物，将已经走过屏幕左边的平台的位置调整到队尾,达到复用的目的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlatformManager</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span>(props) &#123;<br>        <span class="hljs-keyword">this</span>.update = (stage) =&gt; &#123;<br><br>            <span class="hljs-comment">//this.lastPlatform.position.x &lt; stage.width表示前一个平台的左侧已经出现在舞台时，就开始执行&#123;&#125;的内容绘制一个新的平台</span><br>            <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.platforms.length ||<br>                <span class="hljs-keyword">this</span>.lastPlatform.position.x &lt; stage.width) &#123;<br>                <span class="hljs-keyword">const</span> &#123; width, height, gap &#125; = PlatformManager.getRandomProperties(stage);<br>                let prev = !<span class="hljs-keyword">this</span>.platforms.length<br>                    ? <span class="hljs-number">0</span><br>                    : <span class="hljs-keyword">this</span>.lastPlatform.position.x + <span class="hljs-keyword">this</span>.lastPlatform.width + gap;<br>                <span class="hljs-keyword">const</span> newPlatform = new Platform(&#123;<br>                    position: new Vector(prev, stage.height - height),<span class="hljs-comment">//stage.height - height，stage.height是舞台的高度，即整个浏览器的高度，height为一个平台的高度</span><br>                    width: !<span class="hljs-keyword">this</span>.platforms.length<br>                        ? random(stage.width * <span class="hljs-number">0.8</span>, stage.width)<span class="hljs-comment">//每次开始时，第一个舞台的宽度</span><br>                        : width,<span class="hljs-comment">//第二个及以后舞台的宽度</span><br>                    height,<br>                    color: randomOne(<span class="hljs-keyword">this</span>.colors)<span class="hljs-comment">//在自定义的几个颜色中随机舞台颜色</span><br>                &#125;);<br>                <span class="hljs-keyword">this</span>.lastPlatform = newPlatform;<br>                <span class="hljs-keyword">this</span>.platforms.push(newPlatform);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.platforms.length; i++) &#123;<br>                <span class="hljs-keyword">const</span> platform = <span class="hljs-keyword">this</span>.platforms[i];<br>                platform.update(stage);<span class="hljs-comment">//platform的更新方法，不是PlatformManager的，为平台设置速度</span><br>                <span class="hljs-comment">// 如果已经走过屏幕左边,需要将它的位置调整到队尾,达到复用的目的</span><br>                <span class="hljs-keyword">if</span> (platform.position.x + platform.width &lt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">const</span> &#123; width, height, gap &#125; = PlatformManager.getRandomProperties(stage);<br>                    platform.position = new Vector(<span class="hljs-keyword">this</span>.lastPlatform.position.x + <span class="hljs-keyword">this</span>.lastPlatform.width + gap, stage.height - height);<br>                    platform.color = randomOne(<span class="hljs-keyword">this</span>.colors);<br>                    platform.width = width;<br>                    platform.height = height;<br>                    <span class="hljs-keyword">this</span>.lastPlatform = platform;<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//画出平台</span><br>        <span class="hljs-keyword">this</span>.draw = (stage) =&gt; &#123;<br>            <span class="hljs-keyword">this</span>.platforms.forEach((p) =&gt; p.draw(stage));<span class="hljs-comment">//p的draw继承自Rect</span><br>        &#125;;<br>        <span class="hljs-keyword">const</span> &#123; colors &#125; = props;<br>        <span class="hljs-keyword">this</span>.colors = colors;<br>        <span class="hljs-keyword">this</span>.platforms = [];<br>        <span class="hljs-keyword">this</span>.lastPlatform = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//取得平台随机数据</span><br>    static getRandomProperties(stage) &#123;<br>        <span class="hljs-keyword">const</span> width = random(<span class="hljs-number">80</span>, <span class="hljs-number">680</span>);<br>        <span class="hljs-keyword">const</span> height = random(<span class="hljs-number">50</span>, <span class="hljs-number">200</span>);<br>        <span class="hljs-keyword">const</span> gap = random((<span class="hljs-number">80</span> * Math.abs(stage.horizontalVelocity.x)) / <span class="hljs-number">3</span>, (<span class="hljs-number">180</span> * Math.abs(stage.horizontalVelocity.x)) / <span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">return</span> &#123;<br>            width,<br>            height,<br>            gap<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="GameController（游戏控制者）"><a href="#GameController（游戏控制者）" class="headerlink" title="GameController（游戏控制者）"></a>GameController（游戏控制者）</h3><p>此部分主要为初始化事件监听函数（鼠标，键盘，声音）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> listeners = [];<br><span class="hljs-keyword">let</span> lastTime = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> controlType = <span class="hljs-string">&quot;keyboard&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">addListener</span> = (<span class="hljs-params">callback</span>) =&gt; &#123;<br>  listeners.<span class="hljs-title function_">push</span>(callback);<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">notify</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  listeners.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">listener</span>) =&gt;</span> <span class="hljs-title function_">listener</span>());<br>&#125;;<br><span class="hljs-comment">//事件调度函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">eventDispatcher</span> = (<span class="hljs-params"><span class="hljs-keyword">type</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (controlType === <span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-title function_">notify</span>();<br>  &#125;<br>&#125;;<br><span class="hljs-comment">//初始化事件监听器</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initKeyboardListener</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">//键盘事件监听器</span><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;keydown&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">key</span> === <span class="hljs-string">&quot; &quot;</span> || event.<span class="hljs-property">key</span> === <span class="hljs-string">&quot;ArrowUp&quot;</span>) &#123;<br>      <span class="hljs-title function_">eventDispatcher</span>(<span class="hljs-string">&quot;keyboard&quot;</span>);<br>    &#125;<br>  &#125;);<br>  <span class="hljs-comment">//鼠标点击事件监听器</span><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">eventDispatcher</span>(<span class="hljs-string">&quot;keyboard&quot;</span>);<br>  &#125;);<br>&#125;<br><span class="hljs-comment">////初始化声音事件监听器</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initAudioListener</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (navigator.<span class="hljs-property">mediaDevices</span> &amp;&amp; navigator.<span class="hljs-property">mediaDevices</span>.<span class="hljs-property">getUserMedia</span>) &#123;<br>    <span class="hljs-keyword">let</span> audioContext = <span class="hljs-keyword">new</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">AudioContext</span> || <span class="hljs-variable language_">window</span>.<span class="hljs-property">webkitAudioContext</span>)();<br>    <span class="hljs-comment">// 获取用户的 media 信息</span><br>    navigator.<span class="hljs-property">mediaDevices</span>.<span class="hljs-title function_">getUserMedia</span>(&#123; <span class="hljs-attr">audio</span>: <span class="hljs-literal">true</span> &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">stream</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> mediaStreamSource = audioContext.<span class="hljs-title function_">createMediaStreamSource</span>(stream);<br>      <span class="hljs-keyword">const</span> scriptProcessor = audioContext.<span class="hljs-title function_">createScriptProcessor</span>(<span class="hljs-number">4096</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>      mediaStreamSource.<span class="hljs-title function_">connect</span>(scriptProcessor);<br>      scriptProcessor.<span class="hljs-title function_">connect</span>(audioContext.<span class="hljs-property">destination</span>);<br>      scriptProcessor.<span class="hljs-property">onaudioprocess</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>        <span class="hljs-comment">// 获得缓冲区的输入音频，转换为包含了PCM通道数据的32位浮点数组</span><br>        <span class="hljs-keyword">let</span> buffer = e.<span class="hljs-property">inputBuffer</span>.<span class="hljs-title function_">getChannelData</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 获取缓冲区中最大的音量值</span><br>        <span class="hljs-keyword">let</span> maxVal = <span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-title class_">Math</span>, buffer);<br>        <span class="hljs-keyword">if</span> (maxVal * <span class="hljs-number">100</span> &gt; <span class="hljs-number">2</span> &amp;&amp; performance.<span class="hljs-title function_">now</span>() - lastTime &gt; <span class="hljs-number">300</span>) &#123;<br>          lastTime = performance.<span class="hljs-title function_">now</span>();<br>          <span class="hljs-title function_">eventDispatcher</span>(<span class="hljs-string">&quot;audio&quot;</span>);<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(maxVal);<br>        &#125;<br>      &#125;;<br>    &#125;);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">once</span>(<span class="hljs-params">factory</span>) &#123;<br>  <span class="hljs-keyword">let</span> inited = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!inited) &#123;<br>      <span class="hljs-title function_">factory</span>();<br>      inited = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;;<br>&#125;<br><span class="hljs-comment">//调用初始化的事件监听器（键盘及点击）</span><br><span class="hljs-title function_">initKeyboardListener</span>();<br><span class="hljs-keyword">const</span> lazyInitAudioListener = <span class="hljs-title function_">once</span>(initAudioListener);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">setControlType</span> = (<span class="hljs-params"><span class="hljs-keyword">type</span></span>) =&gt; &#123;<br>  controlType = <span class="hljs-keyword">type</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&quot;audio&quot;</span>) &#123;<br>    <span class="hljs-title function_">lazyInitAudioListener</span>();<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>此部分主要为碰撞检测函数，初始化游戏，包括新建实例对象。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing">let init;<br>let herald;<br>let particles = [];<br><span class="hljs-keyword">const</span> maxParticleLength = <span class="hljs-number">40</span>;<br>let particleId = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//创建舞台</span><br><span class="hljs-keyword">const</span> stage = <span class="hljs-keyword">new </span><span class="hljs-class title_">Stage</span>(&#123;<br>  verticalAcceleration: <span class="hljs-keyword">new </span><span class="hljs-class title_">Vector</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0.6</span>),<span class="hljs-comment">// 重力加速度</span><br>  initialHorizontalVelocity: <span class="hljs-keyword">new </span><span class="hljs-class title_">Vector</span>(<span class="hljs-number">-4</span>, <span class="hljs-number">0</span>),<span class="hljs-comment">//初始水平速度</span><br>  horizontalAcceleration: <span class="hljs-keyword">new </span><span class="hljs-class title_">Vector</span>(<span class="hljs-number">-0.001</span>, <span class="hljs-number">0</span>),<span class="hljs-comment">//初始水平加速度</span><br>&#125;);<br>let hasIntersect = <span class="hljs-literal">false</span>;<br>let prevHasIntersect = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//判断是否碰撞到地面方块左侧</span><br>function <span class="hljs-title function_">isIntersectLeft</span>(herald, platform) &#123;<br>  <span class="hljs-keyword">if</span> (herald.<span class="hljs-property">prevPosition</span>.<span class="hljs-property">x</span> + herald.<span class="hljs-property">width</span> &gt;= platform.<span class="hljs-property">prevPosition</span>.<span class="hljs-property">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (herald.<span class="hljs-property">prevPosition</span>.<span class="hljs-property">y</span> + herald.<span class="hljs-property">height</span> &gt;= platform.<span class="hljs-property">prevPosition</span>.<span class="hljs-property">y</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">const</span> &#123; x, y &#125; = platform.<span class="hljs-property">prevPosition</span>;<br>  <span class="hljs-keyword">const</span> prevRightBottomX = herald.<span class="hljs-property">width</span> + herald.<span class="hljs-property">prevPosition</span>.<span class="hljs-property">x</span>;<br>  <span class="hljs-keyword">const</span> prevRightBottomY = herald.<span class="hljs-property">height</span> + herald.<span class="hljs-property">prevPosition</span>.<span class="hljs-property">y</span>;<br>  <span class="hljs-keyword">const</span> tx = (x - prevRightBottomX) / -stage.<span class="hljs-property">horizontalVelocity</span>.<span class="hljs-property">x</span>;<br>  <span class="hljs-keyword">const</span> ty = (y - prevRightBottomY) / herald.<span class="hljs-property">prevVelocity</span>.<span class="hljs-property">y</span>;<br>  <span class="hljs-keyword">return</span> ty &lt; tx;<br>&#125;<br><span class="hljs-comment">//碰撞检测</span><br>function <span class="hljs-title function_">collideDetect</span>(herald, platforms) &#123;<br>  <span class="hljs-comment">//当herald掉下消失在视图中时触发，即游戏结束，注意herald.position.y越往上越小,在浏览器上面的那一边时为0，如果为负则是herald超出浏览器视图</span><br>  <span class="hljs-keyword">if</span> (herald.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> &gt; stage.<span class="hljs-property">height</span>) &#123;<br>    <span class="hljs-title function_">init</span>();<span class="hljs-comment">//游戏失败，初始化游戏</span><br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  let tempHasIntersect = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; platforms.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-comment">//如果herald在与平台相交</span><br>    <span class="hljs-keyword">if</span> (Rect.<span class="hljs-property">isIntersect</span>(herald, platforms[i])) &#123;<br>      tempHasIntersect = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">const</span> platform = platforms[i];<br>      herald.<span class="hljs-property">velocity</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">Vector</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>      herald.<span class="hljs-property">curConJump</span> = <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">//如果碰撞到地面方块左侧</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isIntersectLeft</span>(herald, platform)) &#123;<br>        <span class="hljs-title function_">init</span>();<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      herald.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = platform.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> - herald.<span class="hljs-property">height</span>;<span class="hljs-comment">//纵坐标设置刚好在平台上方。</span><br>      <span class="hljs-keyword">const</span> particleSize = <span class="hljs-number">8</span>;<br>      <span class="hljs-comment">//初次碰撞时的例子效果</span><br>      <span class="hljs-keyword">if</span> (!prevHasIntersect) &#123;<br>        <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>          <span class="hljs-keyword">const</span> left = Math.<span class="hljs-property">random</span>() &gt; <span class="hljs-number">0.5</span>;<br>          particles[particleId % maxParticleLength] = <span class="hljs-keyword">new </span><span class="hljs-class title_">Particle</span>(&#123;<br>            velocity: left<br>              ? <span class="hljs-keyword">new </span><span class="hljs-class title_">Vector</span>(<span class="hljs-built_in">random</span>(<span class="hljs-number">-4</span>, <span class="hljs-number">-2</span>), <span class="hljs-built_in">random</span>(<span class="hljs-number">-6</span>, <span class="hljs-number">-1</span>))<br>              : <span class="hljs-keyword">new </span><span class="hljs-class title_">Vector</span>(<span class="hljs-built_in">random</span>(<span class="hljs-number">10</span>, <span class="hljs-number">16</span>), <span class="hljs-built_in">random</span>(<span class="hljs-number">-6</span>, <span class="hljs-number">-1</span>)),<br>            mass: <span class="hljs-number">1</span>,<br>            position: left<br>              ? <span class="hljs-keyword">new </span><span class="hljs-class title_">Vector</span>(herald.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> - particleSize, herald.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> + herald.<span class="hljs-property">height</span> - particleSize)<br>              : <span class="hljs-keyword">new </span><span class="hljs-class title_">Vector</span>(herald.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> + herald.<span class="hljs-property">width</span>, herald.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> + herald.<span class="hljs-property">height</span> - particleSize),<br>            <span class="hljs-built_in">width</span>: particleSize,<br>            <span class="hljs-built_in">height</span>: particleSize,<br>            <span class="hljs-type">color</span>: <span class="hljs-title function_">randomOne</span>([herald.<span class="hljs-property">color</span>, platform.<span class="hljs-property">color</span>])<br>          &#125;);<br>          particles[particleId++ % maxParticleLength].<span class="hljs-property">applyForce</span>(<span class="hljs-keyword">new </span><span class="hljs-class title_">Vector</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-2</span>));<span class="hljs-comment">//向上的初速度</span><br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">//初次碰撞之后的，即在平台上滑动时的粒子效果</span><br>      <span class="hljs-keyword">else</span> &#123;<br>        particles[particleId % maxParticleLength] = <span class="hljs-keyword">new </span><span class="hljs-class title_">Particle</span>(&#123;<br>          velocity: <span class="hljs-keyword">new </span><span class="hljs-class title_">Vector</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">random</span>(<span class="hljs-number">-6</span>, <span class="hljs-number">-1</span>)),<br>          mass: <span class="hljs-number">1</span>,<br>          position: <span class="hljs-keyword">new </span><span class="hljs-class title_">Vector</span>(herald.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> - particleSize, herald.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> + herald.<span class="hljs-property">height</span> - particleSize),<br>          <span class="hljs-built_in">width</span>: particleSize,<br>          <span class="hljs-built_in">height</span>: particleSize,<br>          <span class="hljs-type">color</span>: platform.<span class="hljs-property">color</span><br>        &#125;);<br>        particles[particleId++ % maxParticleLength].<span class="hljs-property">applyForce</span>(<span class="hljs-keyword">new </span><span class="hljs-class title_">Vector</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-2</span>));<br>      &#125;<br>    &#125;<br>  &#125;<br>  hasIntersect = tempHasIntersect;<br>  <span class="hljs-keyword">if</span> (!prevHasIntersect &amp;&amp; hasIntersect) &#123;<br>    stage.<span class="hljs-property">horizontalVelocity</span>.<span class="hljs-property">add</span>(<span class="hljs-keyword">new </span><span class="hljs-class title_">Vector</span>(<span class="hljs-number">-2</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">//herald回到舞台时，舞台回到初始速度</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (prevHasIntersect &amp;&amp; !hasIntersect) &#123;<br>    stage.<span class="hljs-property">horizontalVelocity</span>.<span class="hljs-property">add</span>(<span class="hljs-keyword">new </span><span class="hljs-class title_">Vector</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">//herald跳起时舞台减速</span><br>  &#125;<br>  prevHasIntersect = hasIntersect;<br>&#125;<br><span class="hljs-comment">//初始游戏</span><br>init = () =&gt; &#123;<br>  stage.<span class="hljs-property">reset</span>();<span class="hljs-comment">//重置舞台</span><br>  <span class="hljs-comment">//创建小方块</span><br>  herald = <span class="hljs-keyword">new </span><span class="hljs-class title_">Herald</span>(&#123;<br>    position: <span class="hljs-keyword">new </span><span class="hljs-class title_">Vector</span>(<span class="hljs-number">160</span>, <span class="hljs-number">20</span>),<br>    <span class="hljs-built_in">height</span>: <span class="hljs-number">24</span>,<br>    <span class="hljs-built_in">width</span>: <span class="hljs-number">24</span>,<br>    <span class="hljs-type">color</span>: <span class="hljs-string">&quot;#222f3e&quot;</span><br>  &#125;);<br>  <span class="hljs-comment">//创建平台方块管理者</span><br>  <span class="hljs-keyword">const</span> pm = <span class="hljs-keyword">new </span><span class="hljs-class title_">PlatformManager</span>(&#123;<br>    colors: [<span class="hljs-string">&quot;#1dd1a1&quot;</span>, <span class="hljs-string">&quot;#ff6b6b&quot;</span>, <span class="hljs-string">&quot;#feca57&quot;</span>, <span class="hljs-string">&quot;#54a0ff&quot;</span>, <span class="hljs-string">&quot;#9c88ff&quot;</span>]<br>  &#125;);<br>  stage.<span class="hljs-property">play</span>(() =&gt; &#123;<br>    <span class="hljs-title function_">collideDetect</span>(herald, pm.<span class="hljs-property">platforms</span>);<span class="hljs-comment">//处于递归环境中，会不断执行</span><br>    <span class="hljs-comment">//改变粒子</span><br>    <span class="hljs-keyword">for</span> (let particle of particles) &#123;<br>      particle.<span class="hljs-property">update</span>(stage);<br>      particle.<span class="hljs-property">draw</span>(stage);<br>    &#125;<br>  &#125;);<br>  <span class="hljs-comment">//在舞台中加入herald和平台管理者</span><br>  stage.<span class="hljs-property">add</span>(herald, pm);<br>&#125;;<br><span class="hljs-comment">//监听input标签，并对游戏模式做出改变</span><br>document.<span class="hljs-property">body</span>.<span class="hljs-property">addEventListener</span>(<span class="hljs-string">&quot;change&quot;</span>, <span class="hljs-title function_">function</span> (event) &#123;<br>  <span class="hljs-title function_">setControlType</span>(event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);<br>&#125;);<br><span class="hljs-comment">//herald跳跃监听</span><br><span class="hljs-title function_">addListener</span>(() =&gt; &#123;<br>  herald.<span class="hljs-property">jump</span>();<br>&#125;);<br><span class="hljs-title function_">init</span>();<br><br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>H5游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期总结</title>
    <url>/2022/08/23/%E6%9A%91%E6%9C%9F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>利用Hexo搭建了个人博客。</li>
<li>完成了《算法 101-JavaScript描述（政采云）》（这本书中大部分题都选自LeetCode,且解法全部为JavaScript,有些解法很好地用到了JavaScript的一些特有语法）共计36道题，并做了<a href="https://yeats.vercel.app/2022/07/29/%E7%AE%97%E6%B3%95-101-JavaScript%E6%8F%8F%E8%BF%B0%EF%BC%88%E6%94%BF%E9%87%87%E4%BA%91%EF%BC%89/">刷题记录</a>，包括思路和注意点。</li>
<li>完成了《🔥 LeetCode 热题 HOT 100》共计25道题，并做了<a href="https://yeats.vercel.app/2022/08/13/%F0%9F%94%A5-LeetCode-%E7%83%AD%E9%A2%98-HOT-100/">刷题记录</a>，包括思路和注意点。</li>
<li>采用HTML+CSS+JavaScript,其中包括了H5中的canvas，参考实现了一款<a href="https://yeats.vercel.app/2022/07/19/%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0H5%E6%B8%B8%E6%88%8F/">H5游戏</a>，并上传到博客。</li>
<li>再次学习了一遍React全家桶.</li>
<li>学习了Webpack.</li>
<li>学习了TypeScript.</li>
</ol>
]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的console.log()</title>
    <url>/2022/08/13/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84console-log/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>偶然在使用JavaScript做题时发现了一个关于console.log()的坑：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a[<span class="hljs-number">0</span>], a);</span><br><span class="language-javascript">        a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a[<span class="hljs-number">0</span>], a);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>理论上在浏览器的控制台中会输出:</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-symbol">0 </span>[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure>

<p>但是，实际上浏览器的输出：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/142994d544704080944a5f502581d519~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>两次输出的数组竟然都是**[0,2,3]**。</p>
<p>但是在<strong>刷新浏览器</strong>后：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/567f4f179494474a98cad60d2dbcdc2b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>发现输出结果是正确的，但是在点击下拉框后发现竟然和输出的数组对不上。</p>
<p>而后我将同样的代码<strong>使用node</strong>进行输出：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6492237ecfe545f382fcf43e25a6dce9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>发现输出结果又是正确的。</p>
<p>至此可以发现输出结果与运行环境有关，应该是浏览器中console.log()中的问题。</p>
<h2 id="探索过程"><a href="#探索过程" class="headerlink" title="探索过程"></a>探索过程</h2><p>然后，通过控制台进行调试，发现在调试过程中，数组a其实发生了变化。这就很奇怪了，为什么调试过程中输出是符合预期的呢？</p>
<p>之后询问了其它大佬，提出过 可以使用JSON.stringify()进行处理，照做之后发现输出结果是正确的:</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddf8e412f8b94e18b96854726466f288~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>为什么通过JSON.stringify()进行处理后，输出结果又是正确的呢？</p>
<p>在查找了相关资料后，发现了原因所在。</p>
<p><strong>《你不知道的JavaScript-中卷》</strong>第二部分第一章中写道：</p>
<p>并没有什么规范或一组需求指定 console.* 方法族如何工作——它们并不是 JavaScript 正式的一部分，而是由宿主环境（请参考本书的“类型和语法”部分）添加到 JavaScript 中的。 因此，不同的浏览器和 JavaScript 环境可以按照自己的意愿来实现，有时候这会引起混淆。 尤其要提出的是，<strong>在某些条件下，某些浏览器的 console.log(..) 并不会把传入的内容立 即输出</strong>。出现这种情况的主要原因是，在许多程序（不只是 JavaScript）中，I&#x2F;O 是非常低 速的阻塞部分。所以，（从页面 &#x2F;UI 的角度来说）浏览器在后台<strong>异步处理</strong>控制台 I&#x2F;O 能够提高性能，这时用户甚至可能根本意识不到其发生。</p>
<p>书中举了一个例子：</p>
<p>下面这种情景不是很常见，但也可能发生，从中（不是从代码本身而是从外部）可以观察到这种情况：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> a = &#123; <span class="hljs-attr">index</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-comment">// 然后 </span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( a );<span class="hljs-comment">// ?? </span><br><span class="hljs-comment">// 再然后 </span><br>a.index++;<br></code></pre></td></tr></table></figure>

<p>我们通常认为恰好在执行到 console.log(..) 语句的时候会看到 a 对象的快照，打印出类 似于 { index: 1 } 这样的内容，然后在下一条语句 a.index++ 执行时将其修改，这句的执行会严格在 a 的输出之后。</p>
<p>多数情况下，前述代码在开发者工具的控制台中输出的对象表示与期望是一致的。但是， 这段代码运行的时候，浏览器可能会认为需要把控制台 I&#x2F;O 延迟到后台，在这种情况下， 等到浏览器控制台输出对象内容时，a.index++ 可能已经执行，因此会显示 { index: 2 }。 到底什么时候控制台 I&#x2F;O 会延迟，甚至是否能够被观察到，这都是游移不定的。如果在调试的过程中遇到对象在 console.log(..) 语句之后被修改，可你却看到了意料之外的结果， 要意识到这可能是这种 <strong>I&#x2F;O 的异步化</strong>造成的.</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul>
<li>如果遇到这种少见的情况，最好的选择是在 JavaScript 调试器中使用断点， 而不要依赖控制台输出。</li>
<li>次优的方案是把对象序列化到一个字符串中，以强制执行一次“快照”，比如通过 JSON.stringify(..)。</li>
</ul>
]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>手撕代码</title>
    <url>/2023/04/10/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="1-Object-create"><a href="#1-Object-create" class="headerlink" title="1.Object.create"></a>1.Object.create</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//实现Object.create方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">proto</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>) &#123;&#125;;<br>    <span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = proto;<br>    <span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Fn</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fn</span>();<br>&#125;<br><span class="hljs-keyword">let</span> demo = &#123;<br>    c : <span class="hljs-string">&#x27;123&#x27;</span><br>&#125;<br><span class="hljs-keyword">let</span> cc = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(demo)<br></code></pre></td></tr></table></figure>

<h2 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2.instanceof"></a>2.instanceof</h2><figure class="highlight nsis"><table><tr><td class="code"><pre><code class="hljs nsis"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceof</span>(<span class="hljs-literal">left</span>, <span class="hljs-literal">right</span>) &#123;<br>  while (<span class="hljs-literal">true</span>) &#123;<br>    if (<span class="hljs-literal">left</span> === null) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><span class="hljs-comment">;</span><br>    &#125;<br>    if (<span class="hljs-literal">left</span>.__proto__ === <span class="hljs-literal">right</span>.prototype) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><span class="hljs-comment">;</span><br>    &#125;<br>    <span class="hljs-literal">left</span> = <span class="hljs-literal">left</span>.__proto__<span class="hljs-comment">;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-new"><a href="#3-new" class="headerlink" title="3.new"></a>3.new</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span><span class="hljs-params">(fn, <span class="hljs-rest_arg">...args</span>)</span> &#123;<br>  let obj = Object.create(fn.prototype);<br>  let res = fn.call(obj, ...args);<br>  <span class="hljs-comment">//不需要考虑fn函数没有返回值的情况，因为函数没有return默认返回undefind，undefind不是对象，没有原型，res instanceof </span><br>  <span class="hljs-comment">// Object返回false</span><br>  <span class="hljs-keyword">if</span> (res <span class="hljs-keyword">instanceof</span> Object) &#123;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>  <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-实现sleep"><a href="#4-实现sleep" class="headerlink" title="4.实现sleep"></a>4.实现sleep</h2><p>某个时间后就去执行某个函数，使用Promise封装</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params">fn, time</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(fn);<br>        &#125;, time);<br>    &#125;);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">autoPlay</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot; 我在sleep 之前&quot;</span>);<br>    <span class="hljs-comment">// 等待多少秒</span><br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">sleep</span>(time);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot; 我在sleep 之后&quot;</span>);<br>&#125;<br><span class="hljs-title function_">autoPlay</span>()<br></code></pre></td></tr></table></figure>

<h2 id="5-Promise"><a href="#5-Promise" class="headerlink" title="5.Promise"></a>5.Promise</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">excutor</span>) &#123;<br>    <span class="hljs-keyword">let</span> that = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 缓存当前promise实例对象</span><br>    that.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PENDING</span>; <span class="hljs-comment">// 初始状态</span><br>    that.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// fulfilled状态时 返回的信息</span><br>    that.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// rejected状态时 拒绝的原因</span><br>    that.<span class="hljs-property">onFulfilledCallbacks</span> = []; <span class="hljs-comment">// 存储fulfilled状态对应的onFulfilled函数</span><br>    that.<span class="hljs-property">onRejectedCallbacks</span> = []; <span class="hljs-comment">// 存储rejected状态对应的onRejected函数</span><br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123; <span class="hljs-comment">// value成功态时接收的终值</span><br>        <span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>            <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">then</span>(resolve, reject);<br>        &#125;<br>        <span class="hljs-comment">// 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-comment">// 调用resolve 回调对应onFulfilled函数</span><br>            <span class="hljs-keyword">if</span> (that.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>                <span class="hljs-comment">// 只能由pending状态 =&gt; fulfilled状态 (避免调用多次resolve reject)</span><br>                that.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span>;<br>                that.<span class="hljs-property">value</span> = value;<br>                that.<span class="hljs-property">onFulfilledCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> <span class="hljs-title function_">cb</span>(that.<span class="hljs-property">value</span>));<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123; <span class="hljs-comment">// reason失败态时接收的拒因</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-comment">// 调用reject 回调对应onRejected函数</span><br>            <span class="hljs-keyword">if</span> (that.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>                <span class="hljs-comment">// 只能由pending状态 =&gt; rejected状态 (避免调用多次resolve reject)</span><br>                that.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span>;<br>                that.<span class="hljs-property">reason</span> = reason;<br>                that.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> <span class="hljs-title function_">cb</span>(that.<span class="hljs-property">reason</span>));<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 捕获在excutor执行器中抛出的异常</span><br>    <span class="hljs-comment">// new Promise((resolve, reject) =&gt; &#123;</span><br>    <span class="hljs-comment">//     throw new Error(&#x27;error in excutor&#x27;)</span><br>    <span class="hljs-comment">// &#125;)</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-title function_">excutor</span>(resolve, reject);<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-title function_">reject</span>(e);<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-keyword">const</span> that = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">let</span> newPromise;<br>    <span class="hljs-comment">// 处理参数默认值 保证参数后续能够继续执行</span><br>    onFulfilled =<br>        <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&quot;function&quot;</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;<br>    onRejected =<br>        <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">throw</span> reason;<br>        &#125;;<br>    <span class="hljs-keyword">if</span> (that.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123; <span class="hljs-comment">// 成功态</span><br>        <span class="hljs-keyword">return</span> newPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onFulfilled</span>(that.<span class="hljs-property">value</span>);<br>                    x <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span> ? x.<span class="hljs-title function_">then</span>(resolve, reject) : <span class="hljs-title function_">resolve</span>(x);<br>                &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>                    <span class="hljs-title function_">reject</span>(e); <span class="hljs-comment">// 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected);</span><br>                &#125;<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (that.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123; <span class="hljs-comment">// 失败态</span><br>        <span class="hljs-keyword">return</span> newPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onRejected</span>(that.<span class="hljs-property">reason</span>);<br>                    x <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span> ? x.<span class="hljs-title function_">then</span>(resolve, reject) : <span class="hljs-title function_">resolve</span>(x);<br>                &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>                    <span class="hljs-title function_">reject</span>(e);<br>                &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (that.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123; <span class="hljs-comment">// 等待态</span><br>        <span class="hljs-comment">// 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中</span><br>        <span class="hljs-keyword">return</span> newPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            that.<span class="hljs-property">onFulfilledCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onFulfilled</span>(value);<br>                    x <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span> ? x.<span class="hljs-title function_">then</span>(resolve, reject) : <span class="hljs-title function_">resolve</span>(x);<br>                &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>                    <span class="hljs-title function_">reject</span>(e);<br>                &#125;<br>            &#125;);<br>            that.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onRejected</span>(reason);<br>                    x <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span> ? x.<span class="hljs-title function_">then</span>(resolve, reject) : <span class="hljs-title function_">resolve</span>(x);<br>                &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>                    <span class="hljs-title function_">reject</span>(e);<br>                &#125;<br>            &#125;);<br>        &#125;);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="6-Promise-all"><a href="#6-Promise-all" class="headerlink" title="6.Promise.all"></a>6.Promise.all</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span>=<span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br><span class="hljs-comment">// 检查是否是迭代对象</span><br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> promises[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span>(<span class="hljs-string">`传入的参数不是一个可迭代对象`</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(promises))&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">`argument must be a array`</span>)<br>    &#125;<br>    <span class="hljs-keyword">var</span> resolvedCounter = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> promiseNum = promises.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">var</span> resolvedResult = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promiseNum; i++) &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promises[i]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>        resolvedCounter++;<br>        resolvedResult[i] = value;<br>        <span class="hljs-keyword">if</span> (resolvedCounter == promiseNum) &#123;<br>            <span class="hljs-title function_">resolve</span>(resolvedResult);<br>          &#125;<br>      &#125;,<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;<br>        <span class="hljs-title function_">reject</span>(error);<br>      &#125;)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="7-Promise-race"><a href="#7-Promise-race" class="headerlink" title="7.Promise.race"></a>7.Promise.race</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params">proms</span>) &#123;<br><span class="hljs-comment">// 检查是否是迭代对象</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> promises[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span>(<span class="hljs-string">`传入的参数不是一个可迭代对象`</span>)<br>&#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> p <span class="hljs-keyword">of</span> proms) &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p).<span class="hljs-title function_">then</span>(resolve, reject);<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="8-Promise-prototype-finally"><a href="#8-Promise-prototype-finally" class="headerlink" title="8.Promise.prototype.finally"></a>8.Promise.prototype.finally</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 无论成功还是失败都会执行回调</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; <span class="hljs-variable">onSettled</span></span><br><span class="hljs-comment">   */</span><br> <span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">finally</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onSettled</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<br>      <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">onSettled</span>(); <span class="hljs-comment">// 实现了收不到参数了</span><br>        <span class="hljs-keyword">return</span> data;<br>      &#125;,<br>      <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">onSettled</span>();<br>        <span class="hljs-keyword">throw</span> reason;<br>      &#125;<br>    );<br>    <span class="hljs-comment">// finally函数 返回结果应该是无效的</span><br>  &#125;<br>  <br><span class="hljs-comment">/******test finally*******/</span><br><span class="hljs-comment">// 无论什么结果，都会运行</span><br><span class="hljs-keyword">const</span> pro = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;);<br><span class="hljs-keyword">const</span> pro2 = pro.<span class="hljs-title function_">finally</span>(<span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;finally&quot;</span>, d); <span class="hljs-comment">// 收不到d参数</span><br>  <span class="hljs-comment">// 本身不改变状态，但是抛出一个错误，数据就会变成它的错误</span><br>  <span class="hljs-comment">// throw 123;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>; <span class="hljs-comment">//不起作用</span><br>&#125;);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pro2);<br>&#125;);<br><br></code></pre></td></tr></table></figure>

<h2 id="9-Promise-allSettled"><a href="#9-Promise-allSettled" class="headerlink" title="9.Promise.allSettled"></a>9.Promise.allSettled</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 等待所有的Promise有结果后</span><br><span class="hljs-comment">   * 该方法返回的Promise完成</span><br><span class="hljs-comment">   * 并且按照顺序将所有结果汇总</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Iterable</span>&#125; <span class="hljs-variable">proms</span></span><br><span class="hljs-comment">   */</span><br>   <br>  <span class="hljs-title class_">Promise</span>.<span class="hljs-property">allSettled</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params">proms</span>) &#123;<br>    <span class="hljs-keyword">const</span> ps = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> p <span class="hljs-keyword">of</span> proms) &#123;<br>      ps.<span class="hljs-title function_">push</span>(<br>        <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p).<span class="hljs-title function_">then</span>(<br>          <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> (&#123;<br>            <span class="hljs-attr">status</span>: <span class="hljs-variable constant_">FULFILLED</span>,<br>            value,<br>          &#125;),<br>          <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> (&#123;<br>            <span class="hljs-attr">status</span>: <span class="hljs-variable constant_">REJECTED</span>,<br>            reason,<br>          &#125;)<br>        )<br>      );<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(ps);<br>  &#125;<br></code></pre></td></tr></table></figure>

<h2 id="10-Promise-prototype-catch"><a href="#10-Promise-prototype-catch" class="headerlink" title="10.Promise.prototype.catch"></a>10.Promise.prototype.catch</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 本质就是then，只是少传了一个onFulfilled</span><br><span class="hljs-comment">   * 所以仅处理失败的场景</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">onRejected</span></span><br><span class="hljs-comment">   */</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">catch</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">onRejected</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, onRejected);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="11-Promise-resolve"><a href="#11-Promise-resolve" class="headerlink" title="11.Promise.resolve"></a>11.Promise.resolve</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span>=<span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-comment">// 如果 value 已经是 Promise 对象，则直接返回该 Promise 对象</span><br>  <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;<br>  <span class="hljs-comment">// 如果 value 是 thenable 对象，则包装成 Promise 对象并返回</span><br>  <span class="hljs-keyword">if</span> (value &amp;&amp; <span class="hljs-keyword">typeof</span> value.<span class="hljs-property">then</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>      value.<span class="hljs-title function_">then</span>(resolve, reject);<br>    &#125;);<br>  &#125;<br>  <span class="hljs-comment">// 将传入的值作为 Promise 的成功值，并返回 Promise 对象</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-title function_">resolve</span>(value);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="12-Promise-reject"><a href="#12-Promise-reject" class="headerlink" title="12.Promise.reject"></a>12.Promise.reject</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 得到一个被拒绝的Promise</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">reason</span></span><br><span class="hljs-comment">  */</span><br> <span class="hljs-title class_">Promise</span>.<span class="hljs-property">reject</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>     <span class="hljs-title function_">reject</span>(reason);<br>   &#125;);<br> &#125;<br></code></pre></td></tr></table></figure>

<h2 id="13-防抖和节流"><a href="#13-防抖和节流" class="headerlink" title="13.防抖和节流"></a>13.防抖和节流</h2><p>setTimeout函数中的第一个参数使用箭头函数时，apply中可直接传入this，因为箭头函数的this指向定义时外部代码块的this，如果不是箭头函数，则需要在外层用一个变量保留this再传入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">callback, time</span>) &#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (timer) &#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timer)<br>        timer = <span class="hljs-literal">null</span><br>      &#125;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        callback.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      &#125;, time);<br>    &#125;<br>  &#125;<br> <br><span class="hljs-comment">// 第一次执行，中间是节流，最后一次也要执行版本</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> lastTime = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> args = <span class="hljs-variable language_">arguments</span>;<br>    <span class="hljs-keyword">const</span> nowTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">if</span> (nowTime - lastTime &gt;= delay) &#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      lastTime = nowTime;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      lastTime = nowTime;<br>	&#125;, delay - (nowTime - lastTime));<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="14-类型判断函数"><a href="#14-类型判断函数" class="headerlink" title="14.类型判断函数"></a>14.类型判断函数</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> get<span class="hljs-constructor">Type(<span class="hljs-params">value</span>)</span> &#123;<br>	return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>prototype.toString.call(value).slice(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>).<span class="hljs-keyword">to</span><span class="hljs-constructor">LowerCase()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="15-call-apply-bind"><a href="#15-call-apply-bind" class="headerlink" title="15.call apply bind"></a>15.call apply bind</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript">Function.prototype.call = <span class="hljs-keyword">function</span><span class="hljs-params">(context, <span class="hljs-rest_arg">...args</span>)</span> &#123;<br>  context = (context === <span class="hljs-literal">undefined</span> || context === <span class="hljs-literal">null</span>) ? window : context<br>  context.__fn = <span class="hljs-keyword">this</span><br>  let result = context.__fn(...args)<br>  <span class="hljs-keyword">delete</span> context.__fn<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br><br>Function.prototype.apply = <span class="hljs-keyword">function</span><span class="hljs-params">(context, args)</span> &#123;<br>  context = (context === <span class="hljs-literal">undefined</span> || context === <span class="hljs-literal">null</span>) ? window : context<br>  context.__fn = <span class="hljs-keyword">this</span><br>  let result = context.__fn(...args)<br>  <span class="hljs-keyword">delete</span> context.__fn<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br><br>Function.prototype.bind = <span class="hljs-keyword">function</span><span class="hljs-params">(context, <span class="hljs-rest_arg">...args1</span>)</span> &#123;<br>  context = (context === <span class="hljs-literal">undefined</span> || context === <span class="hljs-literal">null</span>) ? window : context<br>  let _this = <span class="hljs-keyword">this</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-rest_arg">...args2</span>)</span> &#123;<br>    context.__fn = _this<br>    let result = context.__fn(...[...args1, ...args2])<br>    <span class="hljs-keyword">delete</span> context.__fn<br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="16-curry柯里化"><a href="#16-curry柯里化" class="headerlink" title="16.curry柯里化"></a>16.curry柯里化</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myCurrying</span><span class="hljs-params">(fn)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">curried</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (args.length &gt;= fn.length) &#123;<br>      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, args);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args2</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> curried.apply(<span class="hljs-keyword">this</span>, args.concat(args2));<br>      &#125;;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="17-AJAX请求"><a href="#17-AJAX请求" class="headerlink" title="17.AJAX请求"></a>17.AJAX请求</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> SERVER_URL = <span class="hljs-string">&quot;/server&quot;</span>;<br>let xhr = new XMLHttpRequest();<br><span class="hljs-comment">// 创建 Http 请求</span><br>xhr.<span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, SERVER_URL, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 设置状态监听函数</span><br>xhr.onreadystatechange = function() &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.readyState !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 当请求成功时</span><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">this</span>.status &gt;= <span class="hljs-number">200</span>&amp;&amp;<span class="hljs-keyword">this</span>.status&lt;<span class="hljs-number">300</span>)|| <span class="hljs-keyword">this</span>.status === <span class="hljs-number">304</span>) &#123;<br>    handle(<span class="hljs-keyword">this</span>.response);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    console.error(<span class="hljs-keyword">this</span>.statusText);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 设置请求失败时的监听函数</span><br>xhr.onerror = function() &#123;<br>  console.error(<span class="hljs-keyword">this</span>.statusText);<br>&#125;;<br><span class="hljs-comment">// 设置请求头信息</span><br>xhr.responseType = <span class="hljs-string">&quot;json&quot;</span>;<br>xhr.setRequestHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><span class="hljs-comment">// 发送 Http 请求</span><br>xhr.send(<span class="hljs-literal">null</span>);<br><br></code></pre></td></tr></table></figure>

<h2 id="18-Promise封装AJAX请求"><a href="#18-Promise封装AJAX请求" class="headerlink" title="18.Promise封装AJAX请求"></a>18.Promise封装AJAX请求</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getJSON</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-comment">// 创建一个 promise 对象</span><br>  <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>    <span class="hljs-comment">// 新建一个 http 请求</span><br>    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 设置状态的监听函数</span><br>    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-comment">// 当请求成功或失败时，改变 promise 的状态</span><br>      <span class="hljs-keyword">if</span> ((<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span>&amp;&amp;<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span>&lt;<span class="hljs-number">300</span>)|| <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">304</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>      &#125;<br>    &#125;;<br>    <span class="hljs-comment">// 设置错误监听函数</span><br>    xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>    &#125;;<br>    <span class="hljs-comment">// 设置响应的数据类型</span><br>    xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>    <span class="hljs-comment">// 设置请求头信息</span><br>    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>    <span class="hljs-comment">// 发送 http 请求</span><br>    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="19-实现浅拷贝"><a href="#19-实现浅拷贝" class="headerlink" title="19.实现浅拷贝"></a>19.实现浅拷贝</h2><p>浅拷贝是指，一个新的对象对原始对象的属性值进行精确地拷贝，如果拷贝的是基本数据类型，拷贝的就是基本数据类型的值，如果是引用数据类型，拷贝的就是内存地址。如果其中一个对象的引用内存地址发生改变，另一个对象也会发生变化。</p>
<h3 id="（1）Object-assign"><a href="#（1）Object-assign" class="headerlink" title="（1）Object.assign()"></a>（1）Object.assign()</h3><p><code>Object.assign()</code>是ES6中对象的拷贝方法，接受的第一个参数是目标对象，其余参数是源对象，用法：<code>Object.assign(target, source_1, ···)</code>，该方法可以实现浅拷贝，也可以实现一维对象的深拷贝。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。</li>
<li>如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。</li>
<li>因为<code>null</code> 和 <code>undefined</code> 不能转化为对象，所以第一个参数不能为<code>null</code>或 <code>undefined</code>，会报错。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> target = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">let</span> object2 = &#123;<span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-keyword">let</span> object3 = &#123;<span class="hljs-attr">c</span>: <span class="hljs-number">3</span>&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target,object2,object3);  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target);  <span class="hljs-comment">// &#123;a: 1, b: 2, c: 3&#125;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="（2）扩展运算符"><a href="#（2）扩展运算符" class="headerlink" title="（2）扩展运算符"></a>（2）扩展运算符</h3><p>使用扩展运算符可以在构造字面量对象的时候，进行属性的拷贝。语法：<code>let cloneObj = &#123; ...obj &#125;;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj1 = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:&#123;<span class="hljs-attr">c</span>:<span class="hljs-number">1</span>&#125;&#125;<br><span class="hljs-keyword">let</span> obj2 = &#123;...obj1&#125;;<br>obj1.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1); <span class="hljs-comment">//&#123;a:2,b:&#123;c:1&#125;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">//&#123;a:1,b:&#123;c:1&#125;&#125;</span><br>obj1.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">2</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1); <span class="hljs-comment">//&#123;a:2,b:&#123;c:2&#125;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">//&#123;a:1,b:&#123;c:2&#125;&#125;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="（3）数组方法实现数组浅拷贝"><a href="#（3）数组方法实现数组浅拷贝" class="headerlink" title="（3）数组方法实现数组浅拷贝"></a>（3）数组方法实现数组浅拷贝</h3><h6 id="1）Array-prototype-slice"><a href="#1）Array-prototype-slice" class="headerlink" title="1）Array.prototype.slice"></a><strong>1）Array.prototype.slice</strong></h6><ul>
<li><code>slice()</code>方法是JavaScript数组的一个方法，这个方法可以从已有数组中返回选定的元素：用法：<code>array.slice(start, end)</code>，该方法不会改变原始数组。</li>
<li>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">slice</span>()); <span class="hljs-comment">// [1,2,3,4]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">slice</span>() === arr); <span class="hljs-comment">//false</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h6 id="2）Array-prototype-concat"><a href="#2）Array-prototype-concat" class="headerlink" title="2）Array.prototype.concat"></a><strong>2）Array.prototype.concat</strong></h6><ul>
<li><code>concat()</code> 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</li>
<li>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">concat</span>()); <span class="hljs-comment">// [1,2,3,4]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">concat</span>() === arr); <span class="hljs-comment">//false</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="（4）手写实现浅拷贝"><a href="#（4）手写实现浅拷贝" class="headerlink" title="（4）手写实现浅拷贝"></a>（4）手写实现浅拷贝</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 浅拷贝的实现;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">shallowCopy</span>(<span class="hljs-params">object</span>) &#123;<br>  <span class="hljs-comment">// 只拷贝对象</span><br>  <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// 根据 object 的类型判断是新建一个数组还是对象</span><br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(object) ? [] : &#123;&#125;;<br><br>  <span class="hljs-comment">// 遍历 object，并且判断是 object 的属性才拷贝</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> object) &#123;<br>    <span class="hljs-keyword">if</span> (object.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      newObject[key] = object[key];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> newObject;<br>&#125;<span class="hljs-comment">// 浅拷贝的实现;</span><br></code></pre></td></tr></table></figure>

<h2 id="20-实现深拷贝"><a href="#20-实现深拷贝" class="headerlink" title="20. 实现深拷贝"></a>20. 实现深拷贝</h2><ul>
<li><strong>浅拷贝：</strong> 浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。</li>
<li><strong>深拷贝：</strong> 深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败</li>
</ul>
<h3 id="（1）JSON-stringify"><a href="#（1）JSON-stringify" class="headerlink" title="（1）JSON.stringify()"></a>（1）JSON.stringify()</h3><ul>
<li><code>JSON.parse(JSON.stringify(obj))</code>是目前比较常用的深拷贝方法之一，它的原理就是利用<code>JSON.stringify</code> 将<code>js</code>对象序列化（JSON字符串），再使用<code>JSON.parse</code>来反序列化(还原)<code>js</code>对象。</li>
<li>这个方法可以简单粗暴的实现深拷贝，但是还存在问题，拷贝的对象中如果有函数，undefined，symbol，当使用过<code>JSON.stringify()</code>进行处理之后，都会消失。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj1 = &#123;  <span class="hljs-attr">a</span>: <span class="hljs-number">0</span>,<br>              <span class="hljs-attr">b</span>: &#123;<br>                 <span class="hljs-attr">c</span>: <span class="hljs-number">0</span><br>                 &#125;<br>            &#125;;<br><span class="hljs-keyword">let</span> obj2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj1));<br>obj1.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br>obj1.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">1</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1); <span class="hljs-comment">// &#123;a: 1, b: &#123;c: 1&#125;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">// &#123;a: 0, b: &#123;c: 0&#125;&#125;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="（2）函数库lodash的-cloneDeep方法"><a href="#（2）函数库lodash的-cloneDeep方法" class="headerlink" title="（2）函数库lodash的_.cloneDeep方法"></a>（2）函数库lodash的_.cloneDeep方法</h3><p>该函数库也有提供_.cloneDeep用来做 Deep Copy</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>);<br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">f</span>: &#123; <span class="hljs-attr">g</span>: <span class="hljs-number">1</span> &#125; &#125;,<br>    <span class="hljs-attr">c</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;;<br><span class="hljs-keyword">var</span> obj2 = _.<span class="hljs-title function_">cloneDeep</span>(obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">b</span>.<span class="hljs-property">f</span> === obj2.<span class="hljs-property">b</span>.<span class="hljs-property">f</span>);<span class="hljs-comment">// false</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="（3）手写实现深拷贝函数"><a href="#（3）手写实现深拷贝函数" class="headerlink" title="（3）手写实现深拷贝函数"></a>（3）手写实现深拷贝函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 深拷贝的实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">object</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(object) ? [] : &#123;&#125;;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> object) &#123;<br>    <span class="hljs-keyword">if</span> (object.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      newObject[key] =<br>        <span class="hljs-keyword">typeof</span> object[key] === <span class="hljs-string">&quot;object&quot;</span> ? <span class="hljs-title function_">deepCopy</span>(object[key]) : object[key];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> newObject;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="21-日期格式化函数"><a href="#21-日期格式化函数" class="headerlink" title="21.日期格式化函数"></a>21.日期格式化函数</h2><p>最简易版本的，注意 没有加0的版本<br>格式：年-月-日 时:分:秒</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">formatTime</span>(<span class="hljs-params"></span>) &#123;<br>  const time = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>  const <span class="hljs-built_in">year</span> = time.getFullYear();<br>  const <span class="hljs-built_in">month</span> = time.getMonth() + <span class="hljs-number">1</span>;<br>  const <span class="hljs-built_in">day</span> = time.getDate();<br>  const <span class="hljs-built_in">hour</span> = time.getHours();<br>  const <span class="hljs-built_in">minute</span> = time.getMinutes();<br>  const seconds = time.getSeconds();<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">year</span>&#125;</span>-<span class="hljs-subst">$&#123;<span class="hljs-built_in">month</span>&#125;</span>-<span class="hljs-subst">$&#123;<span class="hljs-built_in">day</span>&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-built_in">hour</span>&#125;</span>:<span class="hljs-subst">$&#123;<span class="hljs-built_in">minute</span>&#125;</span>:<span class="hljs-subst">$&#123;seconds&#125;</span>`</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(formatTime());<br></code></pre></td></tr></table></figure>

<h2 id="22-数组的乱序输出"><a href="#22-数组的乱序输出" class="headerlink" title="22.数组的乱序输出"></a>22.数组的乱序输出</h2><p>主要的实现思路就是：</p>
<ul>
<li>取出数组的第一个元素，随机产生一个索引值，将该第一个元素和这个索引对应的元素进行交换。</li>
<li>第二次取出数据数组第二个元素，随机产生一个除了索引为1的之外的索引值，并将第二个元素与该索引值对应的元素进行交换</li>
<li>按照上面的规律执行，直到遍历完成</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-keyword">const</span> randomIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> - i)) + i;<br>  [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<br></code></pre></td></tr></table></figure>

<h2 id="23-数组的扁平化"><a href="#23-数组的扁平化" class="headerlink" title="23.数组的扁平化"></a>23.数组的扁平化</h2><h3 id="（1）递归实现"><a href="#（1）递归实现" class="headerlink" title="（1）递归实现"></a><strong>（1）递归实现</strong></h3><p>普通的递归思路很容易理解，就是通过循环递归的方式，一项一项地去遍历，如果每一项还是一个数组，那么就继续往下遍历，利用递归程序的方法，来实现数组的每一项的连接：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = [];<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr[i])) &#123;<br>      result = result.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">flatten</span>(arr[i]));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result.<span class="hljs-title function_">push</span>(arr[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-title function_">flatten</span>(arr);  <span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="（2）reduce-函数迭代"><a href="#（2）reduce-函数迭代" class="headerlink" title="（2）reduce 函数迭代"></a>（2）reduce 函数迭代</h3><p>从上面普通的递归函数中可以看出，其实就是对数组的每一项进行处理，那么其实也可以用reduce 来实现数组的拼接，从而简化第一种方法的代码，改造后的代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">prev, next</span>)&#123;<br>        <span class="hljs-keyword">return</span> prev.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(next) ? <span class="hljs-title function_">flatten</span>(next) : next)<br>    &#125;, [])<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr));<span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="（3）扩展运算符实现"><a href="#（3）扩展运算符实现" class="headerlink" title="（3）扩展运算符实现"></a><strong>（3）扩展运算符实现</strong></h3><p>这个方法的实现，采用了扩展运算符和 some 的方法，两者共同使用，达到数组扁平化的目的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">while</span> (arr.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item))) &#123;<br>        arr = [].<span class="hljs-title function_">concat</span>(...arr);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr)); <span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="（4）split-和-toString"><a href="#（4）split-和-toString" class="headerlink" title="（4）split 和 toString"></a><strong>（4）split 和 toString</strong></h3><p>可以通过 split 和 toString 两个方法来共同实现数组扁平化，由于数组会默认带一个 toString 的方法，所以可以把数组直接转换成逗号分隔的字符串，然后再用 split 方法把字符串重新转换为数组，如下面的代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr)); <span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>通过这两个方法可以将多维数组直接转换成逗号连接的字符串，然后再重新分隔成数组。</p>
<h3 id="（5）ES6-中的-flat"><a href="#（5）ES6-中的-flat" class="headerlink" title="（5）ES6 中的 flat"></a><strong>（5）ES6 中的 flat</strong></h3><p>我们还可以直接调用 ES6 中的 flat 方法来实现数组扁平化。flat 方法的语法：<code>arr.flat([depth])</code></p>
<p>其中 depth 是 flat 的参数，depth 是可以传递数组的展开深度（默认不填、数值是 1），即展开一层数组。如果层数不确定，参数可以传进 Infinity，代表不论多少层都要展开：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">flat</span>(<span class="hljs-title class_">Infinity</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr)); <span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>可以看出，一个嵌套了两层的数组，通过将 flat 方法的参数设置为 Infinity，达到了我们预期的效果。其实同样也可以设置成 2，也能实现这样的效果。在编程过程中，如果数组的嵌套层数不确定，最好直接使用 Infinity，可以达到扁平化。 <strong>（6）正则和 JSON 方法</strong> 在第4种方法中已经使用 toString 方法，其中仍然采用了将 JSON.stringify 的方法先转换为字符串，然后通过正则表达式过滤掉字符串中的数组的方括号，最后再利用 JSON.parse 把它转换成数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]], <span class="hljs-number">6</span>];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> str = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(arr);<br>  str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(\[|\])/g</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>  str = <span class="hljs-string">&#x27;[&#x27;</span> + str + <span class="hljs-string">&#x27;]&#x27;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str); <br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr)); <span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br></code></pre></td></tr></table></figure>



<h2 id="24-数组去重"><a href="#24-数组去重" class="headerlink" title="24.数组去重"></a>24.数组去重</h2><p>给定某无序数组，要求去除数组中的重复数字并且返回新的无重复数组。</p>
<p>ES6方法（使用数据结构集合）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>];<br><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(array)); <span class="hljs-comment">// [1, 2, 3, 5, 9, 8]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>ES5方法：使用map存储不重复的数字（可以使用reduce代替for循环）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>];<br><br><span class="hljs-title function_">uniqueArray</span>(array); <span class="hljs-comment">// [1, 2, 3, 5, 9, 8]</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueArray</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">let</span> map = &#123;&#125;;<br>  <span class="hljs-keyword">let</span> res = [];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span>(!map.<span class="hljs-title function_">hasOwnProperty</span>([array[i]])) &#123;<br>      map[array[i]] = <span class="hljs-number">1</span>;<br>      res.<span class="hljs-title function_">push</span>(array[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 方法三 ： filter+indexOf</span><br>const <span class="hljs-keyword">new</span><span class="hljs-type">Arr2</span> = [];<br>arr.filter((item, index) =&gt;&#123;<br><span class="hljs-keyword">if</span>(arr.indexOf(item) === index) &#123;<br><span class="hljs-keyword">new</span><span class="hljs-type">Arr2</span>.push(item)<br>&#125;<br>&#125;)<br>console.log(<span class="hljs-keyword">new</span><span class="hljs-type">Arr2</span>);<br><br><br><span class="hljs-comment">// 方法四 ： includes</span><br>let <span class="hljs-keyword">new</span><span class="hljs-type">Arr3</span> = [];<br><span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i&lt;arr.length; i++) &#123;<br><span class="hljs-keyword">if</span>( !<span class="hljs-keyword">new</span><span class="hljs-type">Arr3</span>.includes(arr[i]) ) &#123;<br><span class="hljs-keyword">new</span><span class="hljs-type">Arr3</span>.push(arr[i]);<br>&#125;<br>&#125;<br>console.log(<span class="hljs-keyword">new</span><span class="hljs-type">Arr3</span>);<br></code></pre></td></tr></table></figure>

<h2 id="25-Array-prototype-flat"><a href="#25-Array-prototype-flat" class="headerlink" title="25.Array.prototype.flat"></a>25.Array.prototype.flat</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">flat</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">deep = <span class="hljs-number">1</span></span>) &#123;<br>    <span class="hljs-keyword">let</span> res = []<br>    deep--<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> p <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(p) &amp;&amp; deep &gt;= <span class="hljs-number">0</span>) &#123;<br>            res = res.<span class="hljs-title function_">concat</span>(p.<span class="hljs-title function_">flat</span>(deep))<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res.<span class="hljs-title function_">push</span>(p)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="26-Array-prototype-push"><a href="#26-Array-prototype-push" class="headerlink" title="26.Array.prototype.push"></a>26.Array.prototype.push</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript">Array.prototype.myPush = <span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...arg</span>)</span> &#123;<br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; arg.length; i++) &#123;<br>    <span class="hljs-keyword">this</span>[<span class="hljs-keyword">this</span>.length] = arg[i];<br>  &#125;        <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.length;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="27-Array-prototype-filter"><a href="#27-Array-prototype-filter" class="headerlink" title="27.Array.prototype.filter"></a>27.Array.prototype.filter</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myFilter</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>[i], i, <span class="hljs-variable language_">this</span>) &amp;&amp; res.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>[i]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="28-Array-prototype-map"><a href="#28-Array-prototype-map" class="headerlink" title="28.Array.prototype.map"></a>28.Array.prototype.map</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">map</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++) &#123;<br>        res.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>[i], i, <span class="hljs-variable language_">this</span>))<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="29-String-prototype-repeat"><a href="#29-String-prototype-repeat" class="headerlink" title="29.String.prototype.repeat"></a>29.String.prototype.repeat</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"> <span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">repeat</span>= <span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">let</span> str = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        res += str;<br>        n--<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-comment">//补充</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">repeat</span>(<span class="hljs-params">s, n</span>) &#123;<br>    <span class="hljs-keyword">return</span> (n &gt; <span class="hljs-number">0</span>) ? s.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">repeat</span>(s, --n)) : <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="30-类数组转化为数组"><a href="#30-类数组转化为数组" class="headerlink" title="30.类数组转化为数组"></a>30.类数组转化为数组</h2><ul>
<li>通过 call 调用数组的 slice 方法来实现转换</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(arrayLike);<br></code></pre></td></tr></table></figure>

<ul>
<li>通过 call 调用数组的 splice 方法来实现转换</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">splice</span>.<span class="hljs-title function_">call</span>(arrayLike, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li>通过 apply 调用数组的 concat 方法来实现转换</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">concat</span>.<span class="hljs-title function_">apply</span>([], arrayLike);<br></code></pre></td></tr></table></figure>

<ul>
<li>通过 Array.from 方法来实现转换</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrayLike);<br></code></pre></td></tr></table></figure>

<h2 id="31-解析-URL-Params-为对象"><a href="#31-解析-URL-Params-为对象" class="headerlink" title="31.解析 URL Params 为对象"></a>31.解析 URL Params 为对象</h2><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">function</span> parseParam(url) &#123;<br>  const paramsStr = <span class="hljs-regexp">/.+\?(.+)$/</span>.exec(url)[<span class="hljs-number">1</span>]; <span class="hljs-regexp">//</span> 将 ? 后面的字符串取出来<br>  const paramsArr = paramsStr.split(<span class="hljs-string">&#x27;&amp;&#x27;</span>); <span class="hljs-regexp">//</span> 将字符串以 &amp; 分割后存到数组中<br>  let paramsObj = &#123;&#125;;<br>  <span class="hljs-regexp">//</span> 将 params 存到对象中<br>  paramsArr.forEach(param =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/=/</span>.test(param)) &#123; <span class="hljs-regexp">//</span> 处理有 value 的参数<br>      let [key, val] = param.split(<span class="hljs-string">&#x27;=&#x27;</span>); <span class="hljs-regexp">//</span> 分割 key 和 value<br>      val = decodeURIComponent(val); <span class="hljs-regexp">//</span> 解码<br>      <span class="hljs-keyword">if</span> (paramsObj.hasOwnProperty(key)) &#123; <span class="hljs-regexp">//</span> 如果对象有 key，则添加一个值<br>        paramsObj[key] = [].concat(paramsObj[key], val);<br>      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-regexp">//</span> 如果对象没有这个 key，创建 key 并设置值<br>        paramsObj[key] = val;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-regexp">//</span> 处理没有 value 的参数<br>      paramsObj[param] = true;<br>    &#125;<br>  &#125;)<br>  return paramsObj;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="32-循环打印红黄绿"><a href="#32-循环打印红黄绿" class="headerlink" title="32.循环打印红黄绿"></a>32.循环打印红黄绿</h2><p>下面来看一道比较典型的问题，通过这个问题来对比几种异步编程方法：<strong>红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？</strong></p>
<p>三个亮灯函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">red</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;red&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">green</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;green&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">yellow</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;yellow&#x27;</span>);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>这道题复杂的地方在于<strong>需要“交替重复”亮灯</strong>，而不是“亮完一次”就结束了。</p>
<h3 id="（1）用-callback-实现"><a href="#（1）用-callback-实现" class="headerlink" title="（1）用 callback 实现"></a>（1）用 callback 实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">task</span> = (<span class="hljs-params">timer, light, callback</span>) =&gt; &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (light === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;<br>            <span class="hljs-title function_">red</span>()<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (light === <span class="hljs-string">&#x27;green&#x27;</span>) &#123;<br>            <span class="hljs-title function_">green</span>()<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (light === <span class="hljs-string">&#x27;yellow&#x27;</span>) &#123;<br>            <span class="hljs-title function_">yellow</span>()<br>        &#125;<br>        <span class="hljs-title function_">callback</span>()<br>    &#125;, timer)<br>&#125;<br><span class="hljs-title function_">task</span>(<span class="hljs-number">3000</span>, <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">task</span>(<span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">task</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br>    &#125;)<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>这里存在一个 bug：代码只是完成了一次流程，执行后红黄绿灯分别只亮一次。该如何让它交替重复进行呢？</p>
<p>上面提到过递归，可以递归亮灯的一个周期：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">step</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">task</span>(<span class="hljs-number">3000</span>, <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">task</span>(<span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">task</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, step)<br>        &#125;)<br>    &#125;)<br>&#125;<br><span class="hljs-title function_">step</span>()<br>复制代码<br></code></pre></td></tr></table></figure>

<p><strong>注意看黄灯亮的回调里又再次调用了 step 方法</strong> 以完成循环亮灯。</p>
<h3 id="（2）用-promise-实现"><a href="#（2）用-promise-实现" class="headerlink" title="（2）用 promise 实现"></a>（2）用 promise 实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">task</span> = (<span class="hljs-params">timer, light</span>) =&gt; <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (light === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;<br>                <span class="hljs-title function_">red</span>()<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (light === <span class="hljs-string">&#x27;green&#x27;</span>) &#123;<br>                <span class="hljs-title function_">green</span>()<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (light === <span class="hljs-string">&#x27;yellow&#x27;</span>) &#123;<br>                <span class="hljs-title function_">yellow</span>()<br>            &#125;<br>            <span class="hljs-title function_">resolve</span>()<br>        &#125;, timer)<br>    &#125;)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">step</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">task</span>(<span class="hljs-number">3000</span>, <span class="hljs-string">&#x27;red&#x27;</span>)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">task</span>(<span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;green&#x27;</span>))<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">task</span>(<span class="hljs-number">2100</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>))<br>        .<span class="hljs-title function_">then</span>(step)<br>&#125;<br><span class="hljs-title function_">step</span>()<br>复制代码<br></code></pre></td></tr></table></figure>

<p>这里将回调移除，在一次亮灯结束后，resolve 当前 promise，并依然使用递归进行。</p>
<h3 id="（3）用-async-x2F-await-实现"><a href="#（3）用-async-x2F-await-实现" class="headerlink" title="（3）用 async&#x2F;await 实现"></a>（3）用 async&#x2F;await 实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">taskRunner</span> =  <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">task</span>(<span class="hljs-number">3000</span>, <span class="hljs-string">&#x27;red&#x27;</span>)<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">task</span>(<span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;green&#x27;</span>)<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">task</span>(<span class="hljs-number">2100</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>)<br>    <span class="hljs-title function_">taskRunner</span>()<br>&#125;<br><span class="hljs-title function_">taskRunner</span>()<br></code></pre></td></tr></table></figure>

<h2 id="33-每隔一秒打印-1-2-3-4"><a href="#33-每隔一秒打印-1-2-3-4" class="headerlink" title="33.每隔一秒打印 1,2,3,4"></a>33.每隔一秒打印 1,2,3,4</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用闭包实现</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    &#125;, i * <span class="hljs-number">1000</span>);<br>  &#125;)(i);<br>&#125;<br><span class="hljs-comment">// 使用 let 块级作用域</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;, i * <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="34-Promise实现图片的异步加载"><a href="#34-Promise实现图片的异步加载" class="headerlink" title="34.Promise实现图片的异步加载"></a>34.Promise实现图片的异步加载</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">imageAsync</span>=(<span class="hljs-params">url</span>)=&gt;&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>                <span class="hljs-keyword">let</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<span class="hljs-comment">//img变量是一个img标签</span><br>                img.<span class="hljs-property">src</span> = url;<br>                img.οnlοad=<span class="hljs-function">()=&gt;</span>&#123;<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`图片请求成功，此处进行通用操作`</span>);<br>                    <span class="hljs-title function_">resolve</span>(image);<br>                &#125;<br>                img.οnerrοr=<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>&#123;<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`失败，此处进行失败的通用操作`</span>);<br>                    <span class="hljs-title function_">reject</span>(err);<br>                &#125;<br>            &#125;)<br>        &#125;<br>        <br><span class="hljs-title function_">imageAsync</span>(<span class="hljs-string">&quot;url&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;加载成功&quot;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;加载失败&quot;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>

<h2 id="35-发布-订阅模式"><a href="#35-发布-订阅模式" class="headerlink" title="35.发布-订阅模式"></a>35.发布-订阅模式</h2><p>题目描述:实现一个发布订阅模式拥有 on emit once off 方法</p>
<p>实现代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = &#123;&#125;;<br>  &#125;<br>  <span class="hljs-comment">// 实现订阅</span><br>  <span class="hljs-title function_">on</span>(<span class="hljs-params">type, callBack</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[type]) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[type] = [callBack];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[type].<span class="hljs-title function_">push</span>(callBack);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 删除订阅</span><br>  <span class="hljs-title function_">off</span>(<span class="hljs-params">type, callBack</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[type]) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[type] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[type].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> item !== callBack;<br>    &#125;);<br>  &#125;<br>  <span class="hljs-comment">// 只执行一次订阅事件</span><br>  <span class="hljs-title function_">once</span>(<span class="hljs-params">type, callBack</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">callBack</span>();<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">off</span>(type, fn);<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(type, fn);<br>  &#125;<br>  <span class="hljs-comment">// 触发事件</span><br>  <span class="hljs-title function_">emit</span>(<span class="hljs-params">type, ...rest</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[type] &amp;&amp;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[type].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, rest));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="36-封装异步的fetch，使用async-await方式来使用"><a href="#36-封装异步的fetch，使用async-await方式来使用" class="headerlink" title="36.封装异步的fetch，使用async await方式来使用"></a>36.封装异步的fetch，使用async await方式来使用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myFetchAsync</span>(<span class="hljs-params">url, options</span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//等 获取到数据</span><br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url, options);<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;response.status&#125;</span> <span class="hljs-subst">$&#123;response.statusText&#125;</span>`</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> response;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>    <span class="hljs-keyword">throw</span> error;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="37-实现简单路由"><a href="#37-实现简单路由" class="headerlink" title="37.实现简单路由"></a>37.实现简单路由</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">function Router()&#123;<br>            <span class="hljs-keyword">this</span>.routes=&#123;&#125;<br>            <span class="hljs-keyword">this</span>.curUrl=<span class="hljs-string">&#x27;&#x27;</span><br> <br>            <span class="hljs-comment">//添加回调函数</span><br>            <span class="hljs-keyword">this</span>.route=function(path,callback)&#123;<br>                <span class="hljs-keyword">this</span>.routes[path]=callback||function()&#123;&#125;<br>            &#125;<br>            <span class="hljs-comment">//执行回调函数</span><br>            <span class="hljs-keyword">this</span>.refresh=function()&#123;<br>                <span class="hljs-comment">//获取url</span><br>                <span class="hljs-keyword">this</span>.curUrl=location.hash.slice(<span class="hljs-number">1</span>)||<span class="hljs-string">&#x27;/&#x27;</span><br>                <span class="hljs-keyword">this</span>.routes[<span class="hljs-keyword">this</span>.curUrl]()<br>            &#125;<br>            <span class="hljs-comment">//监听load和hashchange</span><br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">init</span>=function()&#123;<br>                window.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>,<span class="hljs-keyword">this</span>.refresh.bind(<span class="hljs-keyword">this</span>),<span class="hljs-literal">false</span>)<br>                window.addEventListener(<span class="hljs-string">&#x27;hashchange&#x27;</span>,<span class="hljs-keyword">this</span>.refresh.bind(<span class="hljs-keyword">this</span>),<span class="hljs-literal">false</span>)<br>            &#125;<br>        &#125;<br> <br>        let res=document.getElementById(<span class="hljs-string">&#x27;div&#x27;</span>)<br>        let R=new Router()<br>        <span class="hljs-comment">//触发监听</span><br>        R.<span class="hljs-keyword">init</span>()<br>        R.route(<span class="hljs-string">&#x27;/&#x27;</span>,function()&#123;<br>            res.style.backgroundColor=<span class="hljs-string">&#x27;pink&#x27;</span><br>            res.innerHTML=<span class="hljs-string">&#x27;11111&#x27;</span><br>        &#125;)<br></code></pre></td></tr></table></figure>

<h2 id="38-斐波那契数列"><a href="#38-斐波那契数列" class="headerlink" title="38.斐波那契数列"></a>38.斐波那契数列</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 尾递归</span><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Fibonacci(<span class="hljs-params">n</span>,<span class="hljs-params">num</span>=1,<span class="hljs-params">sum</span>=1)</span>&#123;<br><br>    <span class="hljs-keyword">if</span> (n&lt;=<span class="hljs-number">2</span>)&#123;<br>        return sum;<br>    &#125;<br>    return <span class="hljs-constructor">Fibonacci(<span class="hljs-params">n</span>-1,<span class="hljs-params">sum</span>,<span class="hljs-params">num</span>+<span class="hljs-params">sum</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> feibo3(n) &#123;<br>  <span class="hljs-keyword">let</span> pre = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> cur = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-literal">[<span class="hljs-identifier">pre</span>, <span class="hljs-identifier">cur</span>]</span> = <span class="hljs-literal">[<span class="hljs-identifier">cur</span>, <span class="hljs-identifier">cur</span> + <span class="hljs-identifier">pre</span>]</span>;<br>  &#125;<br>  return cur;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="39-使用-setTimeout-实现-setInterval"><a href="#39-使用-setTimeout-实现-setInterval" class="headerlink" title="39.使用 setTimeout 实现 setInterval"></a>39.使用 setTimeout 实现 setInterval</h2><p>使用 setTimeout 递归调用来模拟 setInterval，确保了只有一个事件结束了，才会触发下一个定时器事件。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> my<span class="hljs-constructor">SetInterval(<span class="hljs-params">fn</span>, <span class="hljs-params">timeout</span>)</span> &#123;<br>  <span class="hljs-comment">// 控制器，控制定时器是否继续执行</span><br>  var timer = &#123;<br>    flag: <span class="hljs-literal">true</span><br>  &#125;;<br>  <span class="hljs-comment">// 设置递归函数，模拟定时器执行。</span><br>  <span class="hljs-keyword">function</span> interval<span class="hljs-literal">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (timer.flag) &#123;<br>      fn<span class="hljs-literal">()</span>;<br>      set<span class="hljs-constructor">Timeout(<span class="hljs-params">interval</span>, <span class="hljs-params">timeout</span>)</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 启动定时器</span><br>  set<span class="hljs-constructor">Timeout(<span class="hljs-params">interval</span>, <span class="hljs-params">timeout</span>)</span>;<br>  <span class="hljs-comment">// 返回控制器</span><br>  return timer;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="40-jsonp"><a href="#40-jsonp" class="headerlink" title="40.jsonp"></a>40.jsonp</h2><h3 id="JSONP-原理"><a href="#JSONP-原理" class="headerlink" title="JSONP 原理"></a>JSONP 原理</h3><ol>
<li>定义好回调函数，比方说命名为 callback ，并将函数名作为 url 的参数；</li>
<li>添加 script 标签，指定的资源为目标域的方法，也就是上面的 url ；</li>
<li>后端接收 GET 请求，返回 <code>callback(responseData)</code> 格式数据，把要返回的数据 responseData 传到 <code>callback()</code> 中；</li>
<li>前端接收 javaScript 内容，执行了后端返回的 <code>callback(responseData)</code> ，这样就完成了一次前后端交互了。</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 动态的加载js文件</span><br><span class="hljs-keyword">function</span> add<span class="hljs-constructor">Script(<span class="hljs-params">src</span>)</span> &#123;<br>  const script = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">script</span>&#x27;)</span>;<br>  script.src = src;<br>  script.<span class="hljs-keyword">type</span> = <span class="hljs-string">&quot;text/javascript&quot;</span>;<br>  document.body.append<span class="hljs-constructor">Child(<span class="hljs-params">script</span>)</span>;<br>&#125;<br>add<span class="hljs-constructor">Script(<span class="hljs-string">&quot;http://xxx.xxx.com/xxx.js?callback=handleRes&quot;</span>)</span>;<br><span class="hljs-comment">// 设置一个全局的callback函数来接收回调结果</span><br><span class="hljs-keyword">function</span> handle<span class="hljs-constructor">Res(<span class="hljs-params">res</span>)</span> &#123;<br>  console.log(res);<br>&#125;<br><span class="hljs-comment">// 接口返回的数据格式</span><br>handle<span class="hljs-constructor">Res(&#123;<span class="hljs-params">a</span>: 1, <span class="hljs-params">b</span>: 2&#125;)</span>;<br></code></pre></td></tr></table></figure>

<h2 id="41-判断对象是否存在循环引用"><a href="#41-判断对象是否存在循环引用" class="headerlink" title="41.判断对象是否存在循环引用"></a>41.判断对象是否存在循环引用</h2><p>对象循环引用会导致垃圾回收机制无法正确回收这些对象，从而导致内存泄漏，使得程序消耗更多的内存，直到最终内存耗尽，导致程序崩溃。</p>
<p>具体来说，当出现循环引用的情况时，垃圾回收机制会出现一些问题。因为垃圾回收机制是通过遍历对象的引用关系来确定哪些对象不再被引用，从而将它们标记为垃圾并回收。但是，当对象之间存在循环引用时，垃圾回收机制无法确定哪些对象是垃圾，哪些对象还在使用中，从而导致无法正确回收垃圾对象，造成内存泄漏。</p>
<p>此外，对象循环引用也会影响程序的性能和稳定性。当内存不足时，程序会变得非常缓慢，甚至无法响应用户的操作，最终导致程序崩溃。</p>
<p><code>JSON.stringify</code>将对象转换为字符串时，会抛出异常。</p>
<p>这是因为在进行对象字符串化时，字符串化工具会尝试遍历整个对象，并将对象中的所有属性都转换为字符串。如果对象中存在循环引用，字符串化工具会陷入死循环，无法正常完成操作。为了防止这种情况发生，字符串化工具会检测对象中是否存在循环引用，如果存在，就会抛出异常，防止程序陷入死循环。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> has<span class="hljs-constructor">CircularReference(<span class="hljs-params">obj</span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> hasCircular = <span class="hljs-literal">false</span>;<br>  const seenObjects = <span class="hljs-keyword">new</span> <span class="hljs-constructor">WeakSet()</span>; <span class="hljs-comment">// 使用WeakSet来存储已经遍历过的对象</span><br><br>  <span class="hljs-keyword">function</span> detect<span class="hljs-constructor">CircularReference(<span class="hljs-params">obj</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (typeof obj<span class="hljs-operator"> === </span>&#x27;<span class="hljs-keyword">object</span>&#x27;<span class="hljs-operator"> &amp;&amp; </span>obj !== null) &#123;<br>      <span class="hljs-keyword">if</span> (seenObjects.has(obj)) &#123;<br>        hasCircular = <span class="hljs-literal">true</span>;<br>        return;<br>      &#125;<br>      seenObjects.add(obj); <span class="hljs-comment">// 标记该对象已经被遍历过</span><br>      <span class="hljs-keyword">for</span> (const key <span class="hljs-keyword">in</span> obj) &#123;<br>        detect<span class="hljs-constructor">CircularReference(<span class="hljs-params">obj</span>[<span class="hljs-params">key</span>])</span>; <span class="hljs-comment">// 遍历该对象的属性</span><br>      &#125;<br>    &#125;<br>  &#125;<br><br>  detect<span class="hljs-constructor">CircularReference(<span class="hljs-params">obj</span>)</span>;<br>  return hasCircular;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="42-继承"><a href="#42-继承" class="headerlink" title="42.继承"></a>42.继承</h2><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span> (parent, child) &#123;<br>    <span class="hljs-comment">// 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span><br>    child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<span class="hljs-comment">//*****</span><br>    child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = child;<span class="hljs-comment">//*****</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent6</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent6&#x27;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br><span class="hljs-title class_">Parent6</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child6</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Parent6</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">//*****</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span> = <span class="hljs-string">&#x27;child5&#x27;</span>;<br>&#125;<br><br><span class="hljs-title function_">clone</span>(<span class="hljs-title class_">Parent6</span>, <span class="hljs-title class_">Child6</span>);<br><br><span class="hljs-title class_">Child6</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getFriends</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> person6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child6</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person6); <span class="hljs-comment">//&#123;friends:&quot;child5&quot;,name:&quot;child5&quot;,play:[1,2,3],__proto__:Parent6&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person6.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// parent6</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person6.<span class="hljs-title function_">getFriends</span>()); <span class="hljs-comment">// child5</span><br></code></pre></td></tr></table></figure>

<h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针</p>
<p>举个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent1&#x27;</span>;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br> &#125;<br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child2&#x27;</span>;<br> &#125;<br> <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>())<br></code></pre></td></tr></table></figure>

<p>上面代码看似没问题，实际存在潜在问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><span class="hljs-keyword">var</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br>s1.<span class="hljs-property">play</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1.<span class="hljs-property">play</span>, s2.<span class="hljs-property">play</span>); <span class="hljs-comment">// [1,2,3,4]</span><br></code></pre></td></tr></table></figure>

<p>改变<code>s1</code>的<code>play</code>属性，会发现<code>s2</code>也跟着发生变化了，这是因为两个实例使用的是同一个原型对象，内存空间是共享的</p>
<h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><p>借助 <code>call</code>调用<code>Parent</code>函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent1&#x27;</span>;<br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title class_">Parent1</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">let</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child);  <span class="hljs-comment">// 没问题</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-title function_">getName</span>());  <span class="hljs-comment">// 会报错</span><br></code></pre></td></tr></table></figure>

<p>可以看到，父类原型对象中一旦存在父类之前自己定义的方法，那么子类将无法继承这些方法</p>
<p>相比第一种原型链继承方式，父类的引用属性不会被共享，优化了第一种继承方式的弊端，但是只能继承父类的实例属性和方法，不能继承原型属性或者方法</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>前面我们讲到两种继承方式，各有优缺点。组合继承则将前两种方式继承起来</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent3</span> () &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent3&#x27;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br><br><span class="hljs-title class_">Parent3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child3</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 第二次调用 Parent3()</span><br>    <span class="hljs-title class_">Parent3</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child3&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// 第一次调用 Parent3()</span><br><span class="hljs-title class_">Child3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent3</span>();<br><span class="hljs-comment">// 手动挂上构造器，指向自己的构造函数</span><br><span class="hljs-title class_">Child3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child3</span>;<br><span class="hljs-keyword">var</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child3</span>();<br><span class="hljs-keyword">var</span> s4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child3</span>();<br>s3.<span class="hljs-property">play</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s3.<span class="hljs-property">play</span>, s4.<span class="hljs-property">play</span>);  <span class="hljs-comment">// 不互相影响</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s3.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// 正常输出&#x27;parent3&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s4.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// 正常输出&#x27;parent3&#x27;</span><br></code></pre></td></tr></table></figure>

<p>这种方式看起来就没什么问题，方式一和方式二的问题都解决了，但是从上面代码我们也可以看到<code>Parent3</code> 执行了两次，造成了多构造一次的性能开销</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>这里主要借助<code>Object.create</code>方法实现普通对象的继承</p>
<p>同样举个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> parent4 = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;parent4&quot;</span>,<br>    <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;p1&quot;</span>, <span class="hljs-string">&quot;p2&quot;</span>, <span class="hljs-string">&quot;p3&quot;</span>],<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-keyword">let</span> person4 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent4);<br>  person4.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;tom&quot;</span>;<br>  person4.<span class="hljs-property">friends</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;jerry&quot;</span>);<br><br>  <span class="hljs-keyword">let</span> person5 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent4);<br>  person5.<span class="hljs-property">friends</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;lucy&quot;</span>);<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person4.<span class="hljs-property">name</span>); <span class="hljs-comment">// tom</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person4.<span class="hljs-property">name</span> === person4.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// true</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person5.<span class="hljs-property">name</span>); <span class="hljs-comment">// parent4</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person4.<span class="hljs-property">friends</span>); <span class="hljs-comment">// [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;]</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person5.<span class="hljs-property">friends</span>); <span class="hljs-comment">// [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;]</span><br></code></pre></td></tr></table></figure>

<p>这种继承方式的缺点也很明显，因为<code>Object.create</code>方法实现的是浅拷贝，多个实例的引用类型属性指向相同的内存，存在篡改的可能</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式继承在上面继承基础上进行优化，利用这个浅拷贝的能力再进行增强，添加一些方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> parent5 = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;parent5&quot;</span>,<br>    <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;p1&quot;</span>, <span class="hljs-string">&quot;p2&quot;</span>, <span class="hljs-string">&quot;p3&quot;</span>],<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">original</span>) &#123;<br>    <span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(original);<br>    clone.<span class="hljs-property">getFriends</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span>;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> clone;<br>&#125;<br><br><span class="hljs-keyword">let</span> person5 = <span class="hljs-title function_">clone</span>(parent5);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person5.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// parent5</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person5.<span class="hljs-title function_">getFriends</span>()); <span class="hljs-comment">// [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;]</span><br></code></pre></td></tr></table></figure>

<p>其优缺点也很明显，跟上面讲的原型式继承一样</p>
<h2 id="43-异步操作串并行执行"><a href="#43-异步操作串并行执行" class="headerlink" title="43.异步操作串并行执行"></a>43.异步操作串并行执行</h2><h3 id="串行执行"><a href="#串行执行" class="headerlink" title="串行执行"></a>串行执行</h3><p>reduce 方法的第一个参数是一个异步函数，它将前一个异步操作的 Promise 对象作为参数传递给下一个异步操作。reduce 方法的第二个参数是一个 Promise 对象，它的值为 undefined。在每次调用 reduce 方法时，都会等待前一个异步操作执行完毕之后再执行下一个异步操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sequentialAsync</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> asyncFunctions = [asyncFunction1, asyncFunction2, asyncFunction3];<br><br>  <span class="hljs-keyword">return</span> asyncFunctions.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">async</span> (previousPromise, asyncFunction) =&gt; &#123;<br>    <span class="hljs-keyword">await</span> previousPromise;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">asyncFunction</span>();<br>  &#125;, <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>());<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">parallelAsync</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [result1, result2, result3] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<br>    <span class="hljs-title function_">asyncFunction1</span>(),<br>    <span class="hljs-title function_">asyncFunction2</span>(),<br>    <span class="hljs-title function_">asyncFunction3</span>(),<br>  ]);<br><br>  <span class="hljs-comment">// 处理异步操作的结果</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="并行与串行的结合"><a href="#并行与串行的结合" class="headerlink" title="并行与串行的结合"></a>并行与串行的结合</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Scheduler</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(max) &#123;<br>    <span class="hljs-comment">// 最大可并发任务数</span><br>    <span class="hljs-keyword">this</span>.max = max;<br>    <span class="hljs-comment">// 当前并发任务数</span><br>    <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">this</span>.queue = [];<br>  &#125;<br><br>  add(fn) &#123;<br>    <span class="hljs-keyword">this</span>.queue.push(fn)<br>    <span class="hljs-keyword">this</span>.run()<br>  &#125;<br>  run() &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.count &gt;= <span class="hljs-keyword">this</span>.max || <span class="hljs-keyword">this</span>.queue.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">this</span>.count++<br>    Promise.resolve(<span class="hljs-keyword">this</span>.queue.shift()()).<span class="hljs-keyword">finally</span>(() =&gt; &#123;<br>      <span class="hljs-keyword">this</span>.count--<br>      <span class="hljs-keyword">this</span>.run()<br>    &#125;)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// ------------test-------------------</span><br><span class="hljs-comment">// 延迟函数</span><br><span class="hljs-keyword">const</span> sleep = time =&gt; new Promise(resolve =&gt; setTimeout(resolve, time));<br><br><span class="hljs-comment">// 同时进行的任务最多2个</span><br><span class="hljs-keyword">const</span> scheduler = new Scheduler(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 添加异步任务</span><br><span class="hljs-comment">// time: 任务执行的时间</span><br><span class="hljs-comment">// val: 参数</span><br><span class="hljs-keyword">const</span> addTask = (time, <span class="hljs-keyword">val</span>) =&gt; &#123;<br>  scheduler.add(() =&gt; &#123;<br>    <span class="hljs-keyword">return</span> sleep(time).then(() =&gt; console.log(<span class="hljs-keyword">val</span>));<br>  &#125;);<br>&#125;;<br><br>addTask(<span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;1&#x27;</span>);<br>addTask(<span class="hljs-number">500</span>, <span class="hljs-string">&#x27;2&#x27;</span>);<br>addTask(<span class="hljs-number">300</span>, <span class="hljs-string">&#x27;3&#x27;</span>);<br>addTask(<span class="hljs-number">400</span>, <span class="hljs-string">&#x27;4&#x27;</span>);<br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure>

<h2 id="44-对象的扁平化"><a href="#44-对象的扁平化" class="headerlink" title="44.对象的扁平化"></a>44.对象的扁平化</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">flattenObject</span>(<span class="hljs-params">obj, prefix = <span class="hljs-string">&#x27;&#x27;</span></span>) &#123;<br>  <span class="hljs-keyword">let</span> result = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(obj, key)) &#123;<br>      <span class="hljs-keyword">const</span> propName = prefix ? <span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span>.<span class="hljs-subst">$&#123;key&#125;</span>`</span> : key;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj[key] === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; obj[key] !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(result, <span class="hljs-title function_">flattenObject</span>(obj[key], propName));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        result[propName] = obj[key];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">//</span><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: &#123;<br>    <span class="hljs-attr">c</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">d</span>: &#123;<br>      <span class="hljs-attr">e</span>: <span class="hljs-number">3</span>,<br>      <span class="hljs-attr">f</span>: <span class="hljs-number">4</span><br>    &#125;<br>  &#125;<br>&#125;;<br><span class="hljs-comment">//</span><br>&#123;<br>  <span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;b.c&quot;</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-string">&quot;b.d.e&quot;</span>: <span class="hljs-number">3</span>,<br>  <span class="hljs-string">&quot;b.d.f&quot;</span>: <span class="hljs-number">4</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="45-版本号排序"><a href="#45-版本号排序" class="headerlink" title="45.版本号排序"></a>45.版本号排序</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> arr1 = a.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>  <span class="hljs-keyword">const</span> arr2 = b.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>);<br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">const</span> s1 = arr1[i];<br>    <span class="hljs-keyword">const</span> s2 = arr2[i];<br>    i++;<br>    <span class="hljs-keyword">if</span> (s1 === <span class="hljs-literal">undefined</span> || s2 === <span class="hljs-literal">undefined</span>) &#123;<br>      <span class="hljs-keyword">return</span> arr1.<span class="hljs-property">length</span> - arr2.<span class="hljs-property">length</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (s1 === s2) <span class="hljs-keyword">continue</span>;<br><br>    <span class="hljs-keyword">return</span> s1 - s2;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h2 id="46-DOM-节点输出为-JSON-格式"><a href="#46-DOM-节点输出为-JSON-格式" class="headerlink" title="46.DOM 节点输出为 JSON 格式"></a>46.DOM 节点输出为 JSON 格式</h2><p>要将一个 DOM 节点输出为 JSON 格式，需要考虑节点的以下属性：</p>
<ol>
<li>tagName - 节点的标签名。</li>
<li>attributes - 节点的属性，需要遍历所有属性并以键值对的形式存储。</li>
<li>childNodes - 节点的子节点，需要递归地对每个子节点进行相同的操作。</li>
</ol>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">nodeToJson</span>(<span class="hljs-params">node</span>) &#123;<br>  <span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>  obj[<span class="hljs-string">&#x27;tagName&#x27;</span>] = node.tagName.toLowerCase();<br><br>  <span class="hljs-keyword">if</span> (node.attributes) &#123;<br>    <span class="hljs-keyword">var</span> attrs = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; node.attributes.<span class="hljs-built_in">length</span>; i++) &#123;<br>      <span class="hljs-keyword">var</span> attr = node.attributes[i];<br>      attrs[attr.nodeName] = attr.nodeValue;<br>    &#125;<br>    obj[<span class="hljs-string">&#x27;attributes&#x27;</span>] = attrs;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">var</span> children = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; node.childNodes.<span class="hljs-built_in">length</span>; j++) &#123;<br>      <span class="hljs-keyword">var</span> childNode = node.childNodes[j];<br>      <span class="hljs-keyword">if</span> (childNode.nodeType === Node.ELEMENT_NODE) &#123;<br>        children.<span class="hljs-built_in">push</span>(nodeToJson(childNode));<br>      &#125;<br>    &#125;<br>    obj[<span class="hljs-string">&#x27;childNodes&#x27;</span>] = children;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br><span class="hljs-comment">//</span><br><span class="hljs-keyword">var</span> node = document.getElementById(<span class="hljs-string">&#x27;my-element&#x27;</span>);<br><span class="hljs-keyword">var</span> json = nodeToJson(node);<br><br></code></pre></td></tr></table></figure>

<h2 id="47-JSON-格式输出为DOM-节点"><a href="#47-JSON-格式输出为DOM-节点" class="headerlink" title="47.JSON 格式输出为DOM 节点"></a>47.JSON 格式输出为DOM 节点</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 真正的渲染函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">_render(<span class="hljs-params">vnode</span>)</span> &#123;<br>  <span class="hljs-comment">// 如果是数字类型转化为字符串</span><br>  <span class="hljs-keyword">if</span> (typeof vnode<span class="hljs-operator"> === </span><span class="hljs-string">&quot;number&quot;</span>) &#123;<br>    vnode = <span class="hljs-constructor">String(<span class="hljs-params">vnode</span>)</span>;<br>  &#125;<br>  <span class="hljs-comment">// 字符串类型直接就是文本节点</span><br>  <span class="hljs-keyword">if</span> (typeof vnode<span class="hljs-operator"> === </span><span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    return document.create<span class="hljs-constructor">TextNode(<span class="hljs-params">vnode</span>)</span>;<br>  &#125;<br>  <span class="hljs-comment">// 普通DOM</span><br>  const dom = document.create<span class="hljs-constructor">Element(<span class="hljs-params">vnode</span>.<span class="hljs-params">tag</span>)</span>;<br>  <span class="hljs-keyword">if</span><span class="hljs-function"> (<span class="hljs-params">vnode.attributes)</span> &#123;</span><br><span class="hljs-function">    // 遍历属性</span><br><span class="hljs-function">    O<span class="hljs-params">bject.keys(vnode.attributes)</span>.<span class="hljs-params">forEach((key)</span> =&gt;</span> &#123;<br>      const value = vnode.attributes<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span>;<br>      dom.set<span class="hljs-constructor">Attribute(<span class="hljs-params">key</span>, <span class="hljs-params">value</span>)</span>;<br>    &#125;);<br>  &#125;<br>  <span class="hljs-comment">// 子数组进行递归操作</span><br>  vnode.children.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each((<span class="hljs-params">child</span>)</span> =&gt; dom.append<span class="hljs-constructor">Child(<span class="hljs-params">_render</span>(<span class="hljs-params">child</span>)</span>));<br>  return dom;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="48-Array-prototype-reduce"><a href="#48-Array-prototype-reduce" class="headerlink" title="48.Array.prototype.reduce"></a>48.Array.prototype.reduce</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">使用方法<br>array.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">accumulator, currentValue, index, array</span>) &#123;<br>  <span class="hljs-comment">// return updated accumulator</span><br>&#125;, initialValue)<br>其中，参数 <span class="hljs-keyword">function</span>(<span class="hljs-params">accumulator, currentValue, index, array</span>) 是一个回调函数，用于处理每个数组元素并更新累加器的值。回调函数接受四个参数：<br><br><span class="hljs-attr">accumulator</span>: 累加器的值，初始值为 initialValue<br><span class="hljs-attr">currentValue</span>: 当前数组元素的值<br><span class="hljs-attr">index</span>: 当前数组元素的索引<br><span class="hljs-attr">array</span>: 原始数组<br>实现方法<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">reduce</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback, initialValue</span>) &#123;<br>  <span class="hljs-keyword">var</span> accumulator = (initialValue !== <span class="hljs-literal">undefined</span>) ? initialValue : <span class="hljs-variable language_">this</span>[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = (initialValue !== <span class="hljs-literal">undefined</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    accumulator = callback.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>, accumulator, <span class="hljs-variable language_">this</span>[i], i, <span class="hljs-variable language_">this</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> accumulator;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="49-实现一个事件委托（易错）"><a href="#49-实现一个事件委托（易错）" class="headerlink" title="49.实现一个事件委托（易错）"></a>49.实现一个事件委托（易错）</h2><p>事件委托这里就不阐述了，比如给li绑定点击事件</p>
<p>看错误版，(容易过的，看<strong>「面试官水平了」</strong>)👇</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">ul.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e,e.<span class="hljs-property">target</span>)<br>            <span class="hljs-keyword">if</span> (e.<span class="hljs-property">target</span>.<span class="hljs-property">tagName</span>.<span class="hljs-title function_">toLowerCase</span>() === <span class="hljs-string">&#x27;li&#x27;</span>) &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;打印&#x27;</span>)  <span class="hljs-comment">// 模拟fn</span><br>            &#125;<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure>

<p><strong>「有个小bug，如果用户点击的是 li 里面的 span，就没法触发 fn，这显然不对」</strong>👇</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">ul</span> id=&quot;xxx&quot;&gt;下面的内容是子元素<span class="hljs-number">1</span><br>        &lt;<span class="hljs-selector-tag">li</span>&gt;<span class="hljs-selector-tag">li</span>内容&gt;&gt;&gt; &lt;<span class="hljs-selector-tag">span</span>&gt; 这是<span class="hljs-selector-tag">span</span>内容<span class="hljs-number">123</span>&lt;/<span class="hljs-selector-tag">span</span>&gt;&lt;/<span class="hljs-selector-tag">li</span>&gt;<br>        下面的内容是子元素<span class="hljs-number">2</span><br>        &lt;<span class="hljs-selector-tag">li</span>&gt;<span class="hljs-selector-tag">li</span>内容&gt;&gt;&gt; &lt;<span class="hljs-selector-tag">span</span>&gt; 这是<span class="hljs-selector-tag">span</span>内容<span class="hljs-number">123</span>&lt;/<span class="hljs-selector-tag">span</span>&gt;&lt;/<span class="hljs-selector-tag">li</span>&gt;<br>        下面的内容是子元素<span class="hljs-number">3</span><br>        &lt;<span class="hljs-selector-tag">li</span>&gt;<span class="hljs-selector-tag">li</span>内容&gt;&gt;&gt; &lt;<span class="hljs-selector-tag">span</span>&gt; 这是<span class="hljs-selector-tag">span</span>内容<span class="hljs-number">123</span>&lt;/<span class="hljs-selector-tag">span</span>&gt;&lt;/<span class="hljs-selector-tag">li</span>&gt;<br>&lt;/<span class="hljs-selector-tag">ul</span>&gt;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>这样子的场景就是不对的，那我们看看高级版本👇</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini">function delegate(element, eventType, selector, fn) &#123;<br>          element.addEventListener(eventType, <span class="hljs-attr">e</span> =&gt; &#123;<br>              let <span class="hljs-attr">el</span> = e.target<br>              while (!el.matches(selector)) &#123;<br>                  if (<span class="hljs-attr">element</span> === el) &#123;<br>                      <span class="hljs-attr">el</span> = null<br>                      break<br>                  &#125;<br>                  <span class="hljs-attr">el</span> = el.parentNode<br>              &#125;<br>              el &amp;&amp; fn.call(el, e, el)<br>          &#125;,true)<br>          return element<br>      &#125;<br></code></pre></td></tr></table></figure>

<h2 id="50-事件的代理"><a href="#50-事件的代理" class="headerlink" title="50.事件的代理"></a>50.事件的代理</h2><p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理。</p>
<p><strong>事件委托的优点</strong></p>
<ul>
<li>只需要将同类元素的事件委托给父级或者更外级的元素，不需要给所有的元素都绑定事件，减少内存占用空间，提升性能。</li>
<li>动态新增的元素无需重新绑定事件</li>
</ul>
<p>错误版：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">ul.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">function</span>(<span class="hljs-params">e</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(e.target.tagName.<span class="hljs-keyword">to</span><span class="hljs-constructor">LowerCase()</span><span class="hljs-operator"> === </span>&#x27;li&#x27;)&#123;<br>        fn<span class="hljs-literal">()</span> <span class="hljs-comment">// 执行某个函数</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>正确版：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">function</span> <span class="hljs-title">delegate</span><span class="hljs-params">(element, eventType, selector, fn)</span> &#123;<br>     element.addEventListener(eventType, <span class="hljs-keyword">e</span> =&gt; &#123;<br>       <span class="hljs-keyword">let</span> <span class="hljs-keyword">el</span> = <span class="hljs-keyword">e</span>.target<br>       <span class="hljs-keyword">while</span> (!el.matches(selector)) &#123;<br>         <span class="hljs-keyword">if</span> (element === <span class="hljs-keyword">el</span>) &#123;<br>           <span class="hljs-keyword">el</span> = null<br>           <span class="hljs-keyword">break</span><br>         &#125;<br>         <span class="hljs-keyword">el</span> = <span class="hljs-keyword">el</span>.parentNode<br>       &#125;<br>       <span class="hljs-keyword">el</span> &amp;&amp; fn.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">el</span>, <span class="hljs-keyword">e</span>, <span class="hljs-keyword">el</span>)<br>     &#125;)<br>     <span class="hljs-keyword">return</span> element<br>   &#125;<br></code></pre></td></tr></table></figure>

<h2 id="51-大数相加"><a href="#51-大数相加" class="headerlink" title="51.大数相加"></a>51.大数相加</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> add(a ,b)&#123;<br>   <span class="hljs-comment">//取两个数字的最大长度</span><br>   <span class="hljs-keyword">let</span> maxLength = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(a.length, b.length);<br>   <span class="hljs-comment">//用0去补齐长度</span><br>   a = a.pad<span class="hljs-constructor">Start(<span class="hljs-params">maxLength</span> , 0)</span>;<span class="hljs-comment">//&quot;0009007199254740991&quot;</span><br>   b = b.pad<span class="hljs-constructor">Start(<span class="hljs-params">maxLength</span> , 0)</span>;<span class="hljs-comment">//&quot;1234567899999999999&quot;</span><br>   <span class="hljs-comment">//定义加法过程中需要用到的变量</span><br>   <span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">let</span> f = <span class="hljs-number">0</span>;   <span class="hljs-comment">//&quot;进位&quot;</span><br>   <span class="hljs-keyword">let</span> sum = <span class="hljs-string">&quot;&quot;</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=maxLength-<span class="hljs-number">1</span> ; i&gt;=<span class="hljs-number">0</span> ; i--)&#123;<br>      t = <span class="hljs-constructor">Number(<span class="hljs-params">a</span>[<span class="hljs-params">i</span>])</span> + <span class="hljs-constructor">Number(<span class="hljs-params">b</span>[<span class="hljs-params">i</span>])</span> + f;<br>      f = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>floor(t/<span class="hljs-number">10</span>);<br>      sum = t%<span class="hljs-number">10</span> + sum;<br>   &#125;<br>   <span class="hljs-keyword">if</span>(f!==<span class="hljs-number">0</span>)&#123;<br>      sum = &#x27;&#x27; + f + sum;<br>   &#125;<br>   return sum;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="52-模板字符串解析功能"><a href="#52-模板字符串解析功能" class="headerlink" title="52.模板字符串解析功能"></a>52.模板字符串解析功能</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> template = <span class="hljs-string">&#x27;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&#x27;</span>;<br><span class="hljs-keyword">let</span> data = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br><span class="hljs-title function_">render</span>(template, data); <span class="hljs-comment">// 我是姓名，年龄18，性别undefined</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">template, data</span>) &#123;<br>  <span class="hljs-keyword">let</span> computed = template.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/g</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">match, key</span>) &#123;<br>    <span class="hljs-keyword">return</span> data[key];<br>  &#125;);<br>  <span class="hljs-keyword">return</span> computed;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="53-列表转成树形结构"><a href="#53-列表转成树形结构" class="headerlink" title="53.列表转成树形结构"></a>53.列表转成树形结构</h2><figure class="highlight xquery"><table><tr><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">function</span> listToTree(list) &#123;<br>            const <span class="hljs-keyword">map</span> = &#123;&#125;;<br>            const roots = [];<br>            <span class="hljs-keyword">for</span> (const <span class="hljs-type">item</span> <span class="hljs-keyword">of</span> list) &#123;<br>                const<span class="hljs-built_in"> id</span> = <span class="hljs-type">item</span><span class="hljs-built_in">.id</span>;<br>                const parentId = <span class="hljs-type">item</span>.parentId;<br>                <span class="hljs-keyword">map</span><span class="hljs-built_in">[id</span>] = &#123; ...<span class="hljs-type">item</span>, children: <span class="hljs-keyword">map</span><span class="hljs-built_in">[id</span>]?.children||[] &#125;;<br>                <span class="hljs-keyword">if</span> (parentId === <span class="hljs-number">0</span>) &#123;<br>                    roots.push(<span class="hljs-keyword">map</span><span class="hljs-built_in">[id</span>]);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">map</span>[parentId])&#123;<br>                        <span class="hljs-keyword">map</span>[parentId]=&#123;children:[]&#125;;<br>                    &#125;<br>                    <span class="hljs-keyword">map</span>[parentId].children.push(<span class="hljs-keyword">map</span><span class="hljs-built_in">[id</span>]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> roots;<br>         &#125;<br></code></pre></td></tr></table></figure>

<h2 id="54-树形结构转成列表"><a href="#54-树形结构转成列表" class="headerlink" title="54.树形结构转成列表"></a>54.树形结构转成列表</h2><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">function treeToList(data) &#123;<br>    let res <span class="hljs-operator">=</span> []<span class="hljs-comment">;</span><br>    const dfs <span class="hljs-operator">=</span> (tree) <span class="hljs-operator">=</span>&gt; &#123;<br>        tree.forEach((item) <span class="hljs-operator">=</span>&gt; &#123;<br>            if (item.children) &#123;<br>                dfs(item.children)<span class="hljs-comment">;</span><br>                delete item.children<span class="hljs-comment">;</span><br>            &#125;<br>            res.push(item)<span class="hljs-comment">;</span><br>        &#125;)<span class="hljs-comment">;</span><br>    &#125;<span class="hljs-comment">;</span><br>    dfs(data)<span class="hljs-comment">;</span><br>    return res<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="55-lodash-get"><a href="#55-lodash-get" class="headerlink" title="55.lodash.get"></a>55.lodash.get</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>            <span class="hljs-attr">foo</span>: &#123;<br>                <span class="hljs-attr">bar</span>: &#123;<br>                    <span class="hljs-attr">baz</span>: <span class="hljs-string">&#x27;Hello World&#x27;</span><br>                &#125;<br>            &#125;<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">source, path, defaultValue = <span class="hljs-literal">undefined</span></span>) &#123;<br>            <span class="hljs-keyword">const</span> paths = path.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>            <span class="hljs-keyword">let</span> result = source;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> p <span class="hljs-keyword">of</span> paths) &#123;<br>                <span class="hljs-keyword">if</span>(result[p]===<span class="hljs-literal">undefined</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>                &#125;<br>                result = result[p];<br>            &#125;<br>            <span class="hljs-keyword">return</span> result === <span class="hljs-literal">undefined</span> ? defaultValue : result;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">get</span>(obj, <span class="hljs-string">&#x27;foo.bar.baz&#x27;</span>));<br></code></pre></td></tr></table></figure>

<h2 id="56-将数字每千分位用逗号隔开"><a href="#56-将数字每千分位用逗号隔开" class="headerlink" title="56.将数字每千分位用逗号隔开"></a>56.将数字每千分位用逗号隔开</h2><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">let format = <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;<br>            let num = n.toString() <span class="hljs-comment">// 转成字符串</span><br>            let decimals = <span class="hljs-string">&#x27;&#x27;</span><br>            <span class="hljs-comment">// 判断是否有小数</span><br>            num.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">&#x27;.&#x27;</span>) &gt; <span class="hljs-number">-1</span> ? decimals = <span class="hljs-string">&#x27;.&#x27;</span>+num.<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>] : decimals<br>            let len = num.<span class="hljs-built_in">length</span><br>            <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">3</span>) &#123;<br>                <span class="hljs-keyword">return</span> num<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                let remainder = len % <span class="hljs-number">3</span><br>                <span class="hljs-keyword">if</span> (remainder &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 不是3的整数倍</span><br>          <span class="hljs-keyword">return</span> num.<span class="hljs-built_in">slice</span>(<span class="hljs-number">0</span>, remainder) + <span class="hljs-string">&#x27;,&#x27;</span> + num.<span class="hljs-built_in">slice</span>(remainder, len).match(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).join(<span class="hljs-string">&#x27;,&#x27;</span>) + decimals<br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 是3的整数倍</span><br>                    <span class="hljs-keyword">return</span> num.<span class="hljs-built_in">slice</span>(<span class="hljs-number">0</span>, len).match(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).join(<span class="hljs-string">&#x27;,&#x27;</span>) + temp<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(format(<span class="hljs-number">12323.33</span>));  <span class="hljs-comment">// &#x27;12,323.33&#x27;</span><br></code></pre></td></tr></table></figure>

<h2 id="57-双向数据绑定"><a href="#57-双向数据绑定" class="headerlink" title="57.双向数据绑定"></a>57.双向数据绑定</h2><p>响应式也可以这这个模式写</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">双向数据绑定<br>let obj = &#123;&#125;<br>let <span class="hljs-selector-tag">input</span> = document<span class="hljs-selector-class">.getElementById</span>(<span class="hljs-string">&#x27;input&#x27;</span>)<br>let <span class="hljs-selector-tag">span</span> = document<span class="hljs-selector-class">.getElementById</span>(<span class="hljs-string">&#x27;span&#x27;</span>)<br><span class="hljs-comment">// 数据劫持</span><br>Object<span class="hljs-selector-class">.defineProperty</span>(obj, <span class="hljs-string">&#x27;text&#x27;</span>, &#123;<br>  configurable: true,<br>  enumerable: true,<br>  <span class="hljs-built_in">get</span>() &#123;<br>    console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;获取数据了&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-built_in">set</span>(newVal) &#123;<br>    console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;数据更新了&#x27;</span>)<br>    <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.value</span> = newVal<br>    <span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.innerHTML</span> = newVal<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// 输入监听</span><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.addEventListener</span>(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-built_in">function</span>(e) &#123;<br>  obj<span class="hljs-selector-class">.text</span> = e<span class="hljs-selector-class">.target</span><span class="hljs-selector-class">.value</span><br>&#125;)<br><br></code></pre></td></tr></table></figure>

<h2 id="58-设计模式"><a href="#58-设计模式" class="headerlink" title="58.设计模式"></a>58.设计模式</h2><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>保证一个类只能被实例一次，每次获取的时候，如果该类已经创建过实例则直接返回该实例，否则创建一个实例保存并返回。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    constructor(name, age) &#123;<br>        <span class="hljs-keyword">if</span> (!Singleton.instance) &#123;<br>            <span class="hljs-built_in">this</span>.name = name<br>            <span class="hljs-built_in">this</span>.age = age<br>            Singleton.instance = <span class="hljs-built_in">this</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> Singleton.instance<br>    &#125;<br>&#125;<br><br>console.log(<span class="hljs-keyword">new</span> <span class="hljs-type">Singleton</span>(<span class="hljs-string">&quot;Taobao&quot;</span>, <span class="hljs-number">18</span>) === <span class="hljs-keyword">new</span> <span class="hljs-type">Singleton</span>(<span class="hljs-string">&quot;Baidu&quot;</span>, <span class="hljs-number">15</span>)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>命令模式</p>
<p>命令模式中的命令指的是一个执行某些特定的事情的指令。</p>
<p>命令模式最常见的应用场景如：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时可以通过一种松耦合的方式来设计程序，使得请求发送者和请求接收者消除彼此之间的耦合关系。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 接收者类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> &#123;<br>    <span class="hljs-title function_">execute</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;接收者执行请求&#x27;</span>)<br>    &#125;<br>  &#125;<br>  <br><span class="hljs-comment">// 命令者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span> &#123;  <br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">receiver</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">receiver</span> = receiver<br>    &#125;<br>    execute () &#123;    <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;命令&#x27;</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">receiver</span>.<span class="hljs-title function_">execute</span>()<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 触发者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoker</span> &#123;   <br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">command</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">command</span> = command<br>    &#125;<br>    <span class="hljs-title function_">invoke</span>(<span class="hljs-params"></span>) &#123;   <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;开始&#x27;</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">command</span>.<span class="hljs-title function_">execute</span>()<br>    &#125;<br>&#125;<br>  <br><span class="hljs-comment">// 仓库</span><br><span class="hljs-keyword">const</span> warehouse = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Receiver</span>();   <br><span class="hljs-comment">// 订单    </span><br><span class="hljs-keyword">const</span> order = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>(warehouse);  <br><span class="hljs-comment">// 客户</span><br><span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Invoker</span>(order);      <br>client.<span class="hljs-title function_">invoke</span>()<br></code></pre></td></tr></table></figure>

<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式指的是定义一系列算法，把他们一个个封装起来，目的就是将算法的使用和算法的实现分离开来。同时它还可以用来封装一系列的规则，可以被替换使用。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">let strategies = &#123;<br>  add: <span class="hljs-keyword">function</span> <span class="hljs-title"></span>(num) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">num</span> + num;<br>  &#125;,<br>  multiply: <span class="hljs-keyword">function</span> <span class="hljs-title"></span>(num) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">num</span> * num;<br>  &#125;,<br>&#125;;<br>let calculateBonus = <span class="hljs-keyword">function</span> <span class="hljs-title"></span>(strategy, num) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">strategies[strategy](num)</span>;<br>&#125;;<br>console.log(calculateBonus(<span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-number">3</span>));<br>console.log(calculateBonus(<span class="hljs-string">&quot;multiply&quot;</span>, <span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure>

<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使它们能够自动更新自己</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = [];<br>  &#125;<br><br>  <span class="hljs-comment">// 添加观察者</span><br>  <span class="hljs-title function_">addObserver</span>(<span class="hljs-params">observer</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">push</span>(observer);<br>  &#125;<br><br>  <span class="hljs-comment">// 移除观察者</span><br>  <span class="hljs-title function_">removeObserver</span>(<span class="hljs-params">observer</span>) &#123;<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">indexOf</span>(observer);<br>    <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 通知观察者</span><br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">observer</span>) =&gt;</span> &#123;<br>      observer.<span class="hljs-title function_">update</span>(data);<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <span class="hljs-title function_">update</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Received data: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试代码</span><br><span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>();<br><span class="hljs-keyword">const</span> observer1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>();<br><span class="hljs-keyword">const</span> observer2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>();<br><br>subject.<span class="hljs-title function_">addObserver</span>(observer1);<br>subject.<span class="hljs-title function_">addObserver</span>(observer2);<br><br>subject.<span class="hljs-title function_">notify</span>(<span class="hljs-string">&#x27;Hello world!&#x27;</span>); <span class="hljs-comment">// Output: Received data: Hello world!</span><br><br>subject.<span class="hljs-title function_">removeObserver</span>(observer1);<br><br>subject.<span class="hljs-title function_">notify</span>(<span class="hljs-string">&#x27;Goodbye world!&#x27;</span>); <span class="hljs-comment">// Output: Received data: Goodbye world!</span><br><br></code></pre></td></tr></table></figure>

<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式是用来创建对象的常见设计模式，在不暴露创建对象的具体逻辑，而是将逻辑进行封装，那么它就可以被称为工厂。工厂模式又叫做静态工厂模式，由一个工厂对象决定创建某一个类的实例。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>调用者创建对象时只要知道其名称即可</li>
<li>扩展性高，如果要新增一个产品，直接扩展一个工厂类即可。</li>
<li>隐藏产品的具体实现，只关心产品的接口。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DownJacket</span> &#123;<br>  <span class="hljs-title function_">production</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;生产羽绒服&#x27;</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Underwear</span>&#123;<br>  <span class="hljs-title function_">production</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;生产内衣&#x27;</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TShirt</span>&#123;<br>  <span class="hljs-title function_">production</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;生产t恤&#x27;</span>)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">clothingFactory</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">downJacket</span> = <span class="hljs-title class_">DownJacket</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">underwear</span> = <span class="hljs-title class_">Underwear</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">t_shirt</span> = <span class="hljs-title class_">TShirt</span><br>  &#125;<br>  <span class="hljs-title function_">getFactory</span>(<span class="hljs-params">clothingType</span>)&#123;<br>    <span class="hljs-keyword">const</span> _production = <span class="hljs-keyword">new</span> <span class="hljs-variable language_">this</span>[clothingType]<br>    <span class="hljs-keyword">return</span> _production.<span class="hljs-title function_">production</span>()<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> clothing = <span class="hljs-keyword">new</span> <span class="hljs-title function_">clothingFactory</span>()<br>clothing.<span class="hljs-title function_">getFactory</span>(<span class="hljs-string">&#x27;t_shirt&#x27;</span>)<span class="hljs-comment">// 生产t恤</span><br></code></pre></td></tr></table></figure>

<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>例如：Proxy</p>
<p>代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转交给本体对象。</p>
<h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>动态地给某个对象添加一些额外的职责。</p>
<p>在不改变原对象的基础上，通过对其进行包装扩展，使原有对象可以满足用户的更复杂需求，而不会影响从这个类中派生的其他对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cellphone</span> &#123;<br>    <span class="hljs-title function_">create</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;生成一个手机&#x27;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">cellphone</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cellphone</span> = cellphone<br>    &#125;<br>    <span class="hljs-title function_">create</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cellphone</span>.<span class="hljs-title function_">create</span>()<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createShell</span>(cellphone)<br>    &#125;<br>    <span class="hljs-title function_">createShell</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;生成手机壳&#x27;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 测试代码</span><br><span class="hljs-keyword">let</span> cellphone = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cellphone</span>()<br>cellphone.<span class="hljs-title function_">create</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;------------&#x27;</span>)<br><span class="hljs-keyword">let</span> dec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Decorator</span>(cellphone)<br>dec.<span class="hljs-title function_">create</span>()<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 101-JavaScript描述（政采云）</title>
    <url>/2022/07/29/%E7%AE%97%E6%B3%95-101-JavaScript%E6%8F%8F%E8%BF%B0%EF%BC%88%E6%94%BF%E9%87%87%E4%BA%91%EF%BC%89/</url>
    <content><![CDATA[<p>未完善…</p>
<h2 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1. 字符串"></a>1. 字符串</h2><h3 id="1-1-整数反转-LeetCode7-Medium"><a href="#1-1-整数反转-LeetCode7-Medium" class="headerlink" title="1.1 整数反转 LeetCode7 Medium"></a>1.1 <a href="https://leetcode.cn/problems/reverse-integer/">整数反转</a> LeetCode7 Medium</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</p>
<p>假设环境不允许存储 64 位整数（有符号或无符号）。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>主要思想是将数字转换为字符串，运用字符串方法求解。先通过typeof判断所给数据是否为number类型，然后运用String()函数将其转换为字符串，再运用split()方法转换为数组，之后运用数组的reverse()方法翻转数组，再运用join()方法变成字符串。最后使用Number函数转成数字。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>注意判断边界情况以及数字正负号的处理。</p>
<h3 id="1-2-有效的字母异位词-LeetCode242-Easy"><a href="#1-2-有效的字母异位词-LeetCode242-Easy" class="headerlink" title="1.2 有效的字母异位词 LeetCode242 Easy"></a>1.2 <a href="https://leetcode.cn/problems/valid-anagram/">有效的字母异位词</a> LeetCode242 Easy</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p>
<h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>先将字符串转为数组，在运用sort()方法进行排序，最后再转为字符串进行比较。</p>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>js中数组不能直接比较。</p>
<h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>创建一个对象，运用for of遍历其中一个字符串，统计每个字符出现的次数并将其作为新建对象的键值。然后再次使用for of遍历另一个字符串，处理键值。最后使用for in遍历那个对象，判断每个键值是否为0，得出结果。</p>
<h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><p>在运用for in和for of时应使用方括号运算符，不能使用点运算符。因为方括号运算符中的表示变量，而点运算符表示字符串。</p>
<h3 id="1-3-字符串转换整数-atoi-LeetCode8-Medium"><a href="#1-3-字符串转换整数-atoi-LeetCode8-Medium" class="headerlink" title="1.3 字符串转换整数 (atoi) LeetCode8 Medium"></a>1.3 <a href="https://leetcode.cn/problems/string-to-integer-atoi/">字符串转换整数 (atoi)</a> LeetCode8 Medium</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 atoi 函数）。</p>
<p>函数 myAtoi(string s) 的算法如下：</p>
<p>读入字符串并丢弃无用的前导空格<br>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。<br>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。<br>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。<br>如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。<br>返回整数作为最终结果。<br>注意：</p>
<p>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>除前导空格或数字后的其余字符串外，请勿忽略任何其他字符。</p>
<h4 id="思路一-1"><a href="#思路一-1" class="headerlink" title="思路一"></a>思路一</h4><p>先运用string的trim()方法去除字符串两端空格，再利用正则表达式提取满足条件的字符，最后判断是否超过边界。</p>
<h4 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h4><p>注意需判断是否超过边界。</p>
<h4 id="思路二-1"><a href="#思路二-1" class="headerlink" title="思路二"></a>思路二</h4><p>先运用string的trim()方法去除字符串两端空格，再利用行 parseInt（）将字符串转为数字，最后判断是否超过边界。</p>
<h4 id="注意-4"><a href="#注意-4" class="headerlink" title="注意"></a>注意</h4><p>注意需判断是否超过边界。</p>
<h3 id="1-4-外观数列-LeetCode38-Medium"><a href="#1-4-外观数列-LeetCode38-Medium" class="headerlink" title="1.4 外观数列 LeetCode38 Medium"></a>1.4 <a href="https://leetcode.cn/problems/count-and-say/">外观数列</a> LeetCode38 Medium</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给定一个正整数 n ，输出外观数列的第 n 项。</p>
<p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p>
<p>你可以将其视作是由递归公式定义的数字字符串序列：</p>
<p>countAndSay(1) &#x3D; “1”<br>countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。<br>前五项如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.     <span class="hljs-number">1</span><br><span class="hljs-attribute">2</span>.     <span class="hljs-number">11</span><br><span class="hljs-attribute">3</span>.     <span class="hljs-number">21</span><br><span class="hljs-attribute">4</span>.     <span class="hljs-number">1211</span><br><span class="hljs-attribute">5</span>.     <span class="hljs-number">111221</span><br></code></pre></td></tr></table></figure>

<p>第一项是数字 1<br>描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 “11”<br>描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 “21”<br>描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 “1211”<br>描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 “111221”<br>要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</p>
<h4 id="思路一-2"><a href="#思路一-2" class="headerlink" title="思路一"></a>思路一</h4><p>运用递归的思想。要得到第n项，即处理第n-1项的结果，运用string的replace（）方法以及正则表达式进行处理替换，终止条件为n&#x3D;&#x3D;&#x3D;1返回’1’。</p>
<h4 id="注意-5"><a href="#注意-5" class="headerlink" title="注意"></a>注意</h4><p>注意正则表达式的写法&#x2F;(\d)\1**{0,}**&#x2F;g，因至少重复0次，另外注意模板字符串的运用使用使用&#96;&#96;反引号包裹${}。</p>
<h4 id="思路二-2"><a href="#思路二-2" class="headerlink" title="思路二"></a>思路二</h4><p>递归法是由 n 到 1 计算相应的值并层层返回的，循环法正好相反，循环法由 1 计算到 n。然后将最终值返回。处理方法和递归的方法一致。</p>
<h4 id="注意-6"><a href="#注意-6" class="headerlink" title="注意"></a>注意</h4><p>注意正则表达式的写法&#x2F;(\d)\1**{0,}**&#x2F;g，因至少重复0次，另外注意模板字符串的运用使用使用&#96;&#96;反引号包裹${}。</p>
<h3 id="1-5-反转字符串-LeetCode344-Easy"><a href="#1-5-反转字符串-LeetCode344-Easy" class="headerlink" title="1.5 反转字符串 LeetCode344 Easy"></a>1.5 <a href="https://leetcode.cn/problems/reverse-string/">反转字符串</a> LeetCode344 Easy</h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一 问题。你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<h4 id="思路一-3"><a href="#思路一-3" class="headerlink" title="思路一"></a>思路一</h4><p>直接运用数组的reverse()方法。</p>
<h4 id="注意-7"><a href="#注意-7" class="headerlink" title="注意"></a>注意</h4><p>无注意事项。</p>
<h4 id="思路二-3"><a href="#思路二-3" class="headerlink" title="思路二"></a>思路二</h4><p>写一个循环，进行首尾替换。可以引入中间变量或运用解构赋值。</p>
<h3 id="1-10-最长回文子串-LeetCode5-Medium"><a href="#1-10-最长回文子串-LeetCode5-Medium" class="headerlink" title="1.10 最长回文子串 LeetCode5 Medium"></a>1.10 <a href="https://leetcode.cn/problems/longest-palindromic-substring/">最长回文子串</a> LeetCode5 Medium</h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<h4 id="思路一-4"><a href="#思路一-4" class="headerlink" title="思路一"></a>思路一</h4><p>暴力解法。用三个嵌套的for循环，列举所有的子串并判断其是否为回文子串，每次判断后记录此子串并与前一次的子串进行长度比较选取较大的子串。</p>
<h4 id="思路二-4"><a href="#思路二-4" class="headerlink" title="思路二"></a>思路二</h4><p>中心扩展。回文子串一定是对称的，所以我们可以每次选择一个中心，然后从中心向两边扩展判断左右字符是否相等。 中心点的选取有两种情况： 当长度为奇数时，以单个字符为中心； 当长度为偶数时，以两个字符之间的空隙为中心。</p>
<h4 id="注意-8"><a href="#注意-8" class="headerlink" title="注意"></a>注意</h4><p>String的slice方法，<strong>s.slice(++i,j)<strong>在执行时</strong>第一个参数为i</strong>而非i+1,应写为++i。</p>
<h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><p>动态规划。动态规划算法的核心就是记住已经解决过的子问题的解。根据字符串的长度，建立一个矩阵 dp, 通过不同情况的判断条件，通过 dp[i][j]表示 s[i] 至 s[j] 所代 表的子串是否是回文子串。不同长度的子串，根据不同的条件进行判断是否为回文子串。长度为 1，一定回文 ；长度为 2 或 3，判断首尾是否相同：s[i] &#x3D;&#x3D;&#x3D; s[j] ；长度 &gt; 3, 首尾字符相同，且去掉首尾之后的子串仍为回文。</p>
<h4 id="注意-9"><a href="#注意-9" class="headerlink" title="注意"></a>注意</h4><p>使用双层for循环遍历时，注意外层表示长度，内层表示字符串的开始位置。如果外层表示开始位置，内层表示长度，则在长度&gt;3时判断<strong>去掉首尾之后的子串</strong>是否为回文会有误。</p>
<h2 id="2-数学"><a href="#2-数学" class="headerlink" title="2. 数学"></a>2. 数学</h2><h3 id="2-1-罗马数字转整数-LeetCode13-Easy"><a href="#2-1-罗马数字转整数-LeetCode13-Easy" class="headerlink" title="2.1 罗马数字转整数 LeetCode13 Easy"></a>2.1 <a href="https://leetcode.cn/problems/roman-to-integer/">罗马数字转整数</a> LeetCode13 Easy</h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。</p>
<h4 id="思路一-5"><a href="#思路一-5" class="headerlink" title="思路一"></a>思路一</h4><p>运用for循环进行遍历，判断是否属于每一种特殊情况并做相关处理以及不属于特殊情况的处理方法。</p>
<h4 id="注意-10"><a href="#注意-10" class="headerlink" title="注意"></a>注意</h4><p>属于特殊情况时，循环计数应+1并写上<code>continue;</code>语句。</p>
<h4 id="思路二-5"><a href="#思路二-5" class="headerlink" title="思路二"></a>思路二</h4><p>使用对象包含每一种特殊情况的取值，然后在罗马数字中遍历此对象，运用sString的includes（）方法判断是否存在特殊情况并作出相应处理，然后运用正则表达式的replace（）方法，替换为空字符串。最后再做常规处理，即无特殊情况的处理。</p>
<h4 id="注意-11"><a href="#注意-11" class="headerlink" title="注意"></a>注意</h4><p>运用for of遍历以及使用对象包含每一种特殊情况的取值的方法，正则表达式的replace（）方法不改变原字符串.</p>
<h3 id="2-2-Fizz-Buzz-LeetCode412-Easy"><a href="#2-2-Fizz-Buzz-LeetCode412-Easy" class="headerlink" title="2.2 Fizz Buzz LeetCode412 Easy"></a>2.2 <a href="https://leetcode.cn/problems/fizz-buzz/">Fizz Buzz</a> LeetCode412 Easy</h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数 n ，找出从 1 到 n 各个整数的 Fizz Buzz 表示，并用字符串数组 answer（下标从 1 开始）返回结果，其中：</p>
<p>answer[i] &#x3D;&#x3D; “FizzBuzz” 如果 i 同时是 3 和 5 的倍数。<br>answer[i] &#x3D;&#x3D; “Fizz” 如果 i 是 3 的倍数。<br>answer[i] &#x3D;&#x3D; “Buzz” 如果 i 是 5 的倍数。<br>answer[i] &#x3D;&#x3D; i （以字符串形式）如果上述条件全不满足。</p>
<h4 id="思路一-6"><a href="#思路一-6" class="headerlink" title="思路一"></a>思路一</h4><p>for循环，判断属于哪种情况并做相应处理，再通过Array的push方法在数组末添加元素。</p>
<h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3. 数组"></a>3. 数组</h2><h3 id="3-1-轮转数组-LeetCode189-Medium"><a href="#3-1-轮转数组-LeetCode189-Medium" class="headerlink" title="3.1 轮转数组 LeetCode189 Medium"></a>3.1 <a href="https://leetcode.cn/problems/rotate-array/">轮转数组</a> LeetCode189 Medium</h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<h4 id="思路一-7"><a href="#思路一-7" class="headerlink" title="思路一"></a>思路一</h4><p>首先计算出需要截取的数组元素的长度，即 k &#x3D; k % nums.length;然后运用Array的splice()方法，截取需要移动的成员，再通过数组的扩展运算符 <code>... </code>并运用Array的unshift()方法，放到数组前面。</p>
<h4 id="注意-12"><a href="#注意-12" class="headerlink" title="注意"></a>注意</h4><p>注意需计算出需要截取的数组元素的长度，可降低时间复杂度，另外需区分Array的splice()和slice()的区别，前者会改变原数组，后者不会改变。</p>
<h4 id="思路二-6"><a href="#思路二-6" class="headerlink" title="思路二"></a>思路二</h4><p>1.首先计算出需要循环移动的次数； 2. 通过数组的 unshift() 和 pop() 方法实现旋转，循环执行 k 次。</p>
<h4 id="注意-13"><a href="#注意-13" class="headerlink" title="注意"></a>注意</h4><p>先使用pop()方法，再使用unshift()方法，unshift()方法将把它的参数插入数组的头部，并将已经存在的元素顺次地移到较高的下标处，这种处理不会占用额外空间。</p>
<h3 id="3-2-只出现一次的数字-LeetCode136-Easy"><a href="#3-2-只出现一次的数字-LeetCode136-Easy" class="headerlink" title="3.2 只出现一次的数字 LeetCode136 Easy"></a>3.2 <a href="https://leetcode.cn/problems/single-number/">只出现一次的数字</a> LeetCode136 Easy</h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出 现了一次的元素。</p>
<h4 id="思路一-8"><a href="#思路一-8" class="headerlink" title="思路一"></a>思路一</h4><p>使用reduce方法,将数组的一个元素与下一个元素做异或比较。由于有一个数只出现了一次，其他数皆出现了两次，最后相同的数都会异或成0，唯一出现的数与0异或就会得到其本身。</p>
<h4 id="注意-14"><a href="#注意-14" class="headerlink" title="注意"></a>注意</h4><p>主要是对于异或的运用。</p>
<h3 id="3-3-两数之和-LeetCode1-Easy"><a href="#3-3-两数之和-LeetCode1-Easy" class="headerlink" title="3.3 两数之和 LeetCode1 Easy"></a>3.3 <a href="https://leetcode.cn/problems/two-sum/">两数之和</a> LeetCode1 Easy</h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p>
<h4 id="思路一-9"><a href="#思路一-9" class="headerlink" title="思路一"></a>思路一</h4><p>通过双重循环，暴力枚举每一种组合，再通过判断语句，如果两数满足和为target，则返回它们的数组下标。</p>
<h4 id="注意-15"><a href="#注意-15" class="headerlink" title="注意"></a>注意</h4><p>因为题目要求元素在答案里不能重复出现，且可以按任何顺序返回答案，所以部分组合已经遍历过，无需重复遍历。</p>
<h4 id="思路二-7"><a href="#思路二-7" class="headerlink" title="思路二"></a>思路二</h4><p>利用哈希表，运用Array的some()方法进行处理，将每个元素的值和它的索引加到表中，检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。</p>
<h4 id="注意-16"><a href="#注意-16" class="headerlink" title="注意"></a>注意</h4><p>判断成立的条件应为<code>typeof lookup[target - v] ===&quot;number&quot;</code>，如果为<code>lookup[target - v]</code>在下标为<strong>0</strong>时会判断错误。</p>
<h3 id="3-4-旋转图像-LeetCode48-Medium"><a href="#3-4-旋转图像-LeetCode48-Medium" class="headerlink" title="3.4 旋转图像  LeetCode48 Medium"></a>3.4 <a href="https://leetcode.cn/problems/rotate-image/">旋转图像</a>  LeetCode48 Medium</h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><p>给定一个 n × n 的二维矩阵表示一个图像，将图像顺时针旋转 90 度。 必须在原地旋转图像，需要直接修改输入的二维矩阵，不要使用另一个矩阵来旋转图像。</p>
<h4 id="思路一-10"><a href="#思路一-10" class="headerlink" title="思路一"></a>思路一</h4><p>先将矩阵沿左上角到右下角的对角线进行对称,运用for双层循环，内层循环的计数值的初始值为外层循环的计数值，然后将矩阵沿垂直中线对称即可。运用for双层循环，内层循环计数值小于Math.floor(n &#x2F; 2)，n为矩阵长度。</p>
<h4 id="注意-17"><a href="#注意-17" class="headerlink" title="注意"></a>注意</h4><p>注意两个for双层循环的内层循环计数值的初始值即范围。</p>
<h3 id="3-5-删除有序数组中的重复项-LeetCode26-Easy"><a href="#3-5-删除有序数组中的重复项-LeetCode26-Easy" class="headerlink" title="3.5 删除有序数组中的重复项  LeetCode26 Easy"></a>3.5 <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">删除有序数组中的重复项</a>  LeetCode26 Easy</h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p>
<p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p>
<p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p>
<p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>判题标准:</p>
<p>系统会用下面的代码来测试你的题解:</p>
<p>int[] nums &#x3D; […]; &#x2F;&#x2F; 输入数组<br>int[] expectedNums &#x3D; […]; &#x2F;&#x2F; 长度正确的期望答案</p>
<p>int k &#x3D; removeDuplicates(nums); &#x2F;&#x2F; 调用</p>
<p>assert k &#x3D;&#x3D; expectedNums.length;<br>for (int i &#x3D; 0; i &lt; k; i++) {<br>    assert nums[i] &#x3D;&#x3D; expectedNums[i];<br>}<br>如果所有断言都通过，那么您的题解将被 通过。</p>
<h4 id="思路一-11"><a href="#思路一-11" class="headerlink" title="思路一"></a>思路一</h4><p>运用for循环，在循环时，如果后面的数与当前循环的值相同，则利用Array的splice()方法，删除当前数，数组长度减一。</p>
<h4 id="注意-18"><a href="#注意-18" class="headerlink" title="注意"></a>注意</h4><p>注意删除数组中的数后，应注意数组长度和循环计数值的关系，，处理后数组长度减一，splice()方法的用法，第一个参数是删除开始位置，第二个参数值删除个数，且改变原数组。</p>
<h4 id="思路二-8"><a href="#思路二-8" class="headerlink" title="思路二"></a>思路二</h4><p>我们用 一个数组 来记录不重复的下标数量，第一个数必定不是重复的，即 nums[0] 肯定是不重复的， 所以从第二项（即 nums[1]）开始，遍历数组，判断该下标的值跟不重复的数组最后一个元素 nums[count] 是否相同，如果不相同，将该元素值赋值给 nums[count + 1] ，然后 count++，继续遍 历。待遍历结束时，我们可以通过 count 数量来判断不重复元素个数，因为 count 是从 0 开始的， 故返回的新数组的长度为 count + 1。</p>
<h4 id="注意-19"><a href="#注意-19" class="headerlink" title="注意"></a>注意</h4><p>注意从第二项开始遍历。</p>
<h3 id="3-14-字母异位词分组-LeetCode49-Medium"><a href="#3-14-字母异位词分组-LeetCode49-Medium" class="headerlink" title="3.14 字母异位词分组 LeetCode49 Medium"></a>3.14 <a href="https://leetcode.cn/problems/group-anagrams/">字母异位词分组</a> LeetCode49 Medium</h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p>
<p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>
<h4 id="思路一-12"><a href="#思路一-12" class="headerlink" title="思路一"></a>思路一</h4><p>排序分类。先创建个空对象，用于储存字母异位词，然后创建个空数组，用与返回结果。遍历数组里的元素，将每个字母异位词进行排序，并将排序后的字符串作为 key，可知 key 值一样的即为字母异位 词，将他们置于同一个数组中， 待上述遍历结束，再遍历对象，将 对象的每一个值，push 到数组中。</p>
<h4 id="思路二-9"><a href="#思路二-9" class="headerlink" title="思路二"></a>思路二</h4><p>计数分类。和思路一的不同在于判断两个字符串是否为字母异位词的方法不同。我们先遍历数组，每次都创建一个长度为 26，元素全是 0 的数组，用于记录每个单词中每个字符出现的次数；然后将其转化为字符串作为 key，将 key 值一样的字母异位词置于同一个数组中。最 后返回数组。</p>
<h4 id="注意-20"><a href="#注意-20" class="headerlink" title="注意"></a>注意</h4><p>数组间不能直接判断是否相同，可以运用JSON.stringify()转换数组为字符串进行判断</p>
<h3 id="3-15-三数之和-LeetCode15-Medium"><a href="#3-15-三数之和-LeetCode15-Medium" class="headerlink" title="3.15 三数之和 LeetCode15 Medium"></a>3.15 <a href="https://leetcode.cn/problems/3sum/">三数之和</a> LeetCode15 Medium</h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<h4 id="思路一-13"><a href="#思路一-13" class="headerlink" title="思路一"></a>思路一</h4><p>首先对数组进行排序，便于在插入的时候去重，进行双指针遍历时，遇到重复的数就方便跳过。设两个指针指向数组首尾，每次计算两个指针所指数与每次遍历的数三数之和，因为数组已经从小到大排序了，所以如果三数之和大于0则尾指针前移，小于0则首指针后移，如果等于0则添加此组合，并进行去重。</p>
<h4 id="注意-21"><a href="#注意-21" class="headerlink" title="注意"></a>注意</h4><p>在数组中因避免这种写法：while(left&lt;right&amp;&amp;r&#x3D;&#x3D;&#x3D;<strong>nums[right-1])</strong>{right–;}，在加粗出容易超出边界。</p>
<h4 id="思路二-10"><a href="#思路二-10" class="headerlink" title="思路二"></a>思路二</h4><p>三重循环，但是<strong>时间会超时</strong>，不做详解。</p>
<h3 id="3-16-无重复字符的最长子串-LeetCode3-Medium"><a href="#3-16-无重复字符的最长子串-LeetCode3-Medium" class="headerlink" title="3.16 无重复字符的最长子串 LeetCode3 Medium"></a>3.16 <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a> LeetCode3 Medium</h3><h4 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h4><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<h4 id="思路一-14"><a href="#思路一-14" class="headerlink" title="思路一"></a>思路一</h4><p>初始化一个数组和最大值， 从前向后遍历字符串， 如果该字符不在数组中（使用Array的indexOf()方法进行判断），则把字符 push 到数组中，并且比较记录下当前最大值。 否则就从头部向外shift字符直到该重复字符被移除（也可以使用slice（）方法直接截断数组,<code>a.slice(a.indexOf(s[i])+1,i+1)</code>）， 如此循环直到结束。</p>
<h4 id="思路二-11"><a href="#思路二-11" class="headerlink" title="思路二"></a>思路二</h4><p>通过for (char of s){}遍历字符串，记录当前正在遍历的不重复字串的子集 string ， 在遍历过程中不断地添加不重复字符，遇到重复字符则截断 string 达到 string 内补字符不重复的条件。</p>
<h2 id="4-链表"><a href="#4-链表" class="headerlink" title="4. 链表"></a>4. 链表</h2><h3 id="4-1-回文链表-LeetCode234-Easy"><a href="#4-1-回文链表-LeetCode234-Easy" class="headerlink" title="4.1 回文链表  LeetCode234 Easy"></a>4.1 <a href="https://leetcode.cn/problems/palindrome-linked-list/">回文链表</a>  LeetCode234 Easy</h3><h4 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h4><p>请判断一个链表是否为回文链表。<strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p>
<h4 id="思路一-15"><a href="#思路一-15" class="headerlink" title="思路一"></a>思路一</h4><p>主要思想为字符串拼接比较，遍历链表，定义两个临时变量为空字符串，做处理<code>a=a+head.val;b=head.val+b;</code>存储正、反两个拼接的字符串， 比较正、反字符串是否相同。</p>
<h4 id="思路二-12"><a href="#思路二-12" class="headerlink" title="思路二"></a>思路二</h4><p>定义一个全局指针初始化值为head，用于正序遍历，运用调用递归函数进行链表的逆序遍历，递归出口为 head 为 null，返回true，即遍历结束，判断正序遍历的节点值是否全部都等于逆序遍历的节点值。</p>
<h4 id="注意-22"><a href="#注意-22" class="headerlink" title="注意"></a>注意</h4><p>注意此方法的空间复杂度为0(n),另外注意递归的使用方法。</p>
<h3 id="4-2-环形链表-LeetCode141-Easy"><a href="#4-2-环形链表-LeetCode141-Easy" class="headerlink" title="4.2 环形链表  LeetCode141 Easy"></a>4.2 <a href="https://leetcode.cn/problems/linked-list-cycle/">环形链表</a>  LeetCode141 Easy</h3><h4 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h4><p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
<p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p>
<h4 id="思路一-16"><a href="#思路一-16" class="headerlink" title="思路一"></a>思路一</h4><p>定义两个指针，即快慢指针，利用while循环，循环条件为快指针不为空以及快指针的next不为空。两个指针同时出发，快指针一次走两步，慢指针一次走一步。 如果快指针和慢指针相遇，则证明此链表是环形链表，不相遇则不是环形链表。</p>
<h4 id="注意-23"><a href="#注意-23" class="headerlink" title="注意"></a>注意</h4><p>注意while循环条件为快指针不为空以及快指针的next不为空。</p>
<h4 id="思路二-13"><a href="#思路二-13" class="headerlink" title="思路二"></a>思路二</h4><p>利用哈希表数据结构，使用Es6的Map数据结构，新建一个空的Map对象，在while中进行遍历，每次循环在Map中新增一个键值对，键名为当前节点，键值为1，遍历中，判断Map 对象中是否存在相同节点且值为 1，即判断该节点是否已经遍历过了，则可得出该链表是否为环形链表。</p>
<h4 id="注意-24"><a href="#注意-24" class="headerlink" title="注意"></a>注意</h4><p>注意该方法空间复杂度为O（n），另外注意Map用法。</p>
<h4 id="思路三-1"><a href="#思路三-1" class="headerlink" title="思路三"></a>思路三</h4><p>运用ES6中新引入的一种数据类型–Symbol，它代表独一无二的值:</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">let s1 <span class="hljs-operator">=</span> Symbol()<span class="hljs-comment">;</span><br>let s2 <span class="hljs-operator">=</span> Symbol()<span class="hljs-comment">;</span><br><br><span class="hljs-attribute">s1</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> s2 // false<br></code></pre></td></tr></table></figure>

<p>在遍历中将每个节点的 val 值改为用 Symbol 创建的独一无二的值，若循环过程中存在节点的 val 等于这个值，那么证明当前不是第一次循环到该节点，即链表为环形链表，反之不是。</p>
<h3 id="4-3-删除链表中的节点-LeetCode237-Easy"><a href="#4-3-删除链表中的节点-LeetCode237-Easy" class="headerlink" title="4.3 删除链表中的节点  LeetCode237 Easy"></a>4.3 <a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/">删除链表中的节点</a>  LeetCode237 Easy</h3><h4 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h4><p>请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。</p>
<p>题目数据保证需要删除的节点 不是末尾节点 。</p>
<h4 id="思路一-17"><a href="#思路一-17" class="headerlink" title="思路一"></a>思路一</h4><p>删除给定的节点，在获取当前节点后，将下一个节点的值赋给当前节点， 然后将当前节点指向下下个节点，完成删除。</p>
<h4 id="思路二-14"><a href="#思路二-14" class="headerlink" title="思路二"></a>思路二</h4><p>利用Object.assign() 方法， Object.assign(a,b) 能合并两个对象(a和b)，并覆盖到第一个参数(a)所指的地址上（可以改变地址），让node.next覆盖 node，<strong>即node的所有属性都是node.next的所有属性，包括next和val.</strong></p>
<h4 id="注意-25"><a href="#注意-25" class="headerlink" title="注意"></a>注意</h4><p>Object.assign(node,node.next)，即node的所有属性都是node.next的所有属性，包括next和val.</p>
<h3 id="4-4-反转链表-LeetCode206-Easy"><a href="#4-4-反转链表-LeetCode206-Easy" class="headerlink" title="4.4 反转链表  LeetCode206 Easy"></a>4.4 <a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a>  LeetCode206 Easy</h3><h4 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h4><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题</p>
<h4 id="思路一-18"><a href="#思路一-18" class="headerlink" title="思路一"></a>思路一</h4><p>用迭代的方法实现. 先存储其前一个节点，在遍历链表过程中，申请一个新的临时空间用于前后元素交换。</p>
<h4 id="思路二-15"><a href="#思路二-15" class="headerlink" title="思路二"></a>思路二</h4><p>用递归的方法实现。</p>
<h4 id="注意-26"><a href="#注意-26" class="headerlink" title="注意"></a>注意</h4><p>注意每层递归函数都返回反转前的尾结点，也就是反转后的头节点（<strong>返回的结点是不变的，且此返回值不对后续处理造成影响</strong>），此外为了防止链表循环，需要将head.next设置为空。还有再次注意到js中null表示空，这需要与c语言中NULL做区分。</p>
<h3 id="4-5-删除链表的倒数第-N-个结点-LeetCode19-Medium"><a href="#4-5-删除链表的倒数第-N-个结点-LeetCode19-Medium" class="headerlink" title="4.5 删除链表的倒数第 N 个结点  LeetCode19 Medium"></a>4.5 <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a>  LeetCode19 Medium</h3><h4 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h4><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<h4 id="思路一-19"><a href="#思路一-19" class="headerlink" title="思路一"></a>思路一</h4><p> 双指针法。先设first和second指向head，让first 指针前进 n，如果 first为空，说明要删除的节点正是 head 节点，那么直接返回 head 的下一个节点。如果不为空，则让让 second 从 head 开始和 first 一起前进，直到 first 到了最后，此时 second 的下一个节点就是要删除的节点，做出 second.next &#x3D; second.next.next处理。</p>
<h4 id="注意-27"><a href="#注意-27" class="headerlink" title="注意"></a>注意</h4><p>注意first为空时的处理，还有<strong>second.next &#x3D; second.next.nex</strong>t这一步，而不是second.next&#x3D;first，这仅适用于n为2时。</p>
<h4 id="思路二-16"><a href="#思路二-16" class="headerlink" title="思路二"></a>思路二</h4><p> 单向链表成为双向链表。先遍历，让单向链表成为双向链表，先找到其尾节点，从这个节点向前查找，n–，直到n&#x3D;1时，此时的节点就是我们要找的节点，然后直接删除。</p>
<h3 id="4-6-合并两个有序链表-LeetCode21-Easy"><a href="#4-6-合并两个有序链表-LeetCode21-Easy" class="headerlink" title="4.6 合并两个有序链表  LeetCode21 Easy"></a>4.6 <a href="https://leetcode.cn/problems/merge-two-sorted-lists/">合并两个有序链表</a>  LeetCode21 Easy</h3><h4 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h4><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<h4 id="思路一-20"><a href="#思路一-20" class="headerlink" title="思路一"></a>思路一</h4><p>创建一个新链表，通过判断两个链表当前值，将较小值放到新链表的下个节点，较小值的链表重新赋值为其下一节点，直到参数链表都为空时结束。</p>
<h4 id="思路二-17"><a href="#思路二-17" class="headerlink" title="思路二"></a>思路二</h4><p>用递归的方式， 若两个链表中有一个链表为空，则返回另一个链表,依次比较两个链表中首项的大小，保留数值小的为链表当前值，直到一个链表参数为空则结束。</p>
<h3 id="4-7-两数相加-LeetCode2-Medium"><a href="#4-7-两数相加-LeetCode2-Medium" class="headerlink" title="4.7 两数相加  LeetCode2 Medium"></a>4.7 <a href="https://leetcode.cn/problems/add-two-numbers/">两数相加</a>  LeetCode2 Medium</h3><h4 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h4><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<h4 id="思路一-21"><a href="#思路一-21" class="headerlink" title="思路一"></a>思路一</h4><p>由于输入的两个链表都是<strong>逆序</strong>存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。</p>
<h4 id="注意-28"><a href="#注意-28" class="headerlink" title="注意"></a>注意</h4><p>注意需要保存进位值用于下一位相加，另外当链表遍历完时，如果进位值大于0，应<strong>再加一个结点存储进位值</strong>。</p>
<h4 id="思路二-18"><a href="#思路二-18" class="headerlink" title="思路二"></a>思路二</h4><p>将输入的链表转换为逆序的字符串（<strong>字符串</strong>可以更容易的取出每一位数，无论是正序取出还是逆序取出），再将字符串转换为数（可以考虑使用BigInt,确保精度），然后将两个链表转换的数相加，再转换为字符串，然后逆序放入新的链表。</p>
<h2 id="5-二叉树"><a href="#5-二叉树" class="headerlink" title="5. 二叉树"></a>5. 二叉树</h2><h3 id="5-1-最小栈-LeetCode155-Medium"><a href="#5-1-最小栈-LeetCode155-Medium" class="headerlink" title="5.1 最小栈  LeetCode155 Medium"></a>5.1 <a href="https://leetcode.cn/problems/min-stack/">最小栈</a>  LeetCode155 Medium</h3><h4 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h4><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>实现 MinStack 类:</p>
<p>MinStack() 初始化堆栈对象。<br>void push(int val) 将元素val推入堆栈。<br>void pop() 删除堆栈顶部的元素。<br>int top() 获取堆栈顶部的元素。<br>int getMin() 获取堆栈中的最小元素。</p>
<h4 id="思路一-22"><a href="#思路一-22" class="headerlink" title="思路一"></a>思路一</h4><p> 创建最小元素栈时，开辟两个数组，一个用于存储压栈元素，另一个用于存储最小元素序列。push栈数据同时，存储当前栈中最小元素，pop栈数据的同时pop最小元素栈栈顶数据.</p>
<h4 id="思路二-19"><a href="#思路二-19" class="headerlink" title="思路二"></a>思路二</h4><p>用一个 min 变量保存最小值,min初始值为0（只要不超出数值范围均可，因为后面在第一次push时，会将入栈的值赋值给min，但是建议为0，因为不容易出现溢出），每次push操作压栈时,保存的是入栈的值和最小值min的差值，而不是入栈的值。pop出栈时，通过 min 值和栈顶的值得到。</p>
<h4 id="注意-29"><a href="#注意-29" class="headerlink" title="注意"></a>注意</h4><p>注意仅第一次push时，会将入栈的值赋值给min（需要对数组的长度进行判断），另外在top方法中应注意处理数组长度为1时，直接返回数组中唯一的值，不需要再加min,因为数组的第一个值就是min.最后注意在两数差值有溢出风险。</p>
<h2 id="6-动态规划"><a href="#6-动态规划" class="headerlink" title="6. 动态规划"></a>6. 动态规划</h2><h3 id="6-1-最大子数组和-LeetCode53-Medium"><a href="#6-1-最大子数组和-LeetCode53-Medium" class="headerlink" title="6.1 最大子数组和 LeetCode53 Medium"></a>6.1 <a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a> LeetCode53 Medium</h3><h4 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中的一个连续部分。</p>
<p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>
<h4 id="思路一-23"><a href="#思路一-23" class="headerlink" title="思路一"></a>思路一</h4><p>从数组获取第一个值为最大值和中间值 ,遍历数组，如果中间值大于0,则和中间值相加，相加结果和最大值比较，较大值赋值给最大值。如果中间值小于0，则将当前值作为中间值。</p>
<h4 id="思路二-20"><a href="#思路二-20" class="headerlink" title="思路二"></a>思路二</h4><p>分治方法。运用递归，每次求得左右两半部分各自最大子数组和，然后处理两个部分一起的最大子数组和。递归结束条件为左右下标相等。</p>
<h3 id="6-2-爬楼梯-LeetCode70-Easy"><a href="#6-2-爬楼梯-LeetCode70-Easy" class="headerlink" title="6.2 爬楼梯 LeetCode70 Easy"></a>6.2 <a href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a> LeetCode70 Easy</h3><h4 id="题目-25"><a href="#题目-25" class="headerlink" title="题目"></a>题目</h4><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<h4 id="思路一-24"><a href="#思路一-24" class="headerlink" title="思路一"></a>思路一</h4><p>递归+记忆化数组。递归函数：f(n) &#x3D; f(n − 1) + f(n − 2)，创建一个记忆化数组，记录楼层计算过的结果，降低时间复杂度。</p>
<h4 id="思路二-21"><a href="#思路二-21" class="headerlink" title="思路二"></a>思路二</h4><p>动态规划+滚动数组。f(n) &#x3D; f(n − 1) + f(n − 2)。但是由于这里的f(n)只和 f(n - 1) 与 f(n - 2)有关，所以可以用滚动数组思想.</p>
<h3 id="6-6-跳跃游戏-LeetCode55-Medium"><a href="#6-6-跳跃游戏-LeetCode55-Medium" class="headerlink" title="6.6 跳跃游戏 LeetCode55 Medium"></a>6.6 <a href="https://leetcode.cn/problems/jump-game/">跳跃游戏</a> LeetCode55 Medium</h3><h4 id="题目-26"><a href="#题目-26" class="headerlink" title="题目"></a>题目</h4><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标。</p>
<h4 id="思路一-25"><a href="#思路一-25" class="headerlink" title="思路一"></a>思路一</h4><p>贪心。先初始化最远位置为0，然后遍历数组，如果当前位置能到达，并且当前位置+跳数&gt;最远位置，就更新最远位置， 每次循环都比较当前最远位置和当前数组下标，如果最远距离小于等于当前下标就返回false。</p>
<h4 id="思路二-22"><a href="#思路二-22" class="headerlink" title="思路二"></a>思路二</h4><p>动态规划。遍历数组，每到一个点 ，我们就去判断是否可以到达当前点；如果可以，就记录true，否则为 false，最后判断是否可以到达最后一个点。</p>
<h3 id="6-7-不同路径-LeetCode62-Medium"><a href="#6-7-不同路径-LeetCode62-Medium" class="headerlink" title="6.7 不同路径 LeetCode62 Medium"></a>6.7 <a href="https://leetcode.cn/problems/unique-paths/">不同路径</a> LeetCode62 Medium</h3><h4 id="题目-27"><a href="#题目-27" class="headerlink" title="题目"></a>题目</h4><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<h4 id="思路一-26"><a href="#思路一-26" class="headerlink" title="思路一"></a>思路一</h4><p>动态规划。利用双层for循环，状态转移方程为 dp[i][j] &#x3D; dp[i − 1][j] + dp[i][j − 1]。</p>
<h4 id="思路二-23"><a href="#思路二-23" class="headerlink" title="思路二"></a>思路二</h4><p>深度优先搜索+记忆化数组。dfs[i][j] &#x3D; dfs[i − 1][j] + dfs[i][j − 1]。开辟一个记忆数组记录结果。</p>
<h4 id="思路三-2"><a href="#思路三-2" class="headerlink" title="思路三"></a>思路三</h4><p>组合数学。从左上角到右下角的过程中，我们需要移动 m+n-2 次，其中有 m-1次向下移动，n-1次向右移动。因此路径的总数，就等于从 m+n-2次移动中选择 m-1次向下移动的方案数。</p>
<h2 id="7-回溯算法"><a href="#7-回溯算法" class="headerlink" title="7. 回溯算法"></a>7. 回溯算法</h2><h3 id="7-1-括号生成-LeetCode22-Medium"><a href="#7-1-括号生成-LeetCode22-Medium" class="headerlink" title="7.1 括号生成 LeetCode22 Medium"></a>7.1 <a href="https://leetcode.cn/problems/generate-parentheses/">括号生成</a> LeetCode22 Medium</h3><h4 id="题目-28"><a href="#题目-28" class="headerlink" title="题目"></a>题目</h4><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<h4 id="思路一-27"><a href="#思路一-27" class="headerlink" title="思路一"></a>思路一</h4><p>采用回溯法，如果自定义的字符串长度刚好满足条件，那么就说明这个组合是正确的的，把它放入数组。 否则，递归执行添加左括号，添加右括号的操作。递归结束条件为结果字符串长度等于左右括号的总个数（2n），则返回最终结果。</p>
<h3 id="7-3-电话号码的字母组合-LeetCode17-Medium"><a href="#7-3-电话号码的字母组合-LeetCode17-Medium" class="headerlink" title="7.3 电话号码的字母组合 LeetCode17 Medium"></a>7.3 <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">电话号码的字母组合</a> LeetCode17 Medium</h3><h4 id="题目-29"><a href="#题目-29" class="headerlink" title="题目"></a>题目</h4><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png"></p>
<h4 id="思路一-28"><a href="#思路一-28" class="headerlink" title="思路一"></a>思路一</h4><p>利用队列的先进先出的特点，把队列中的第一个元素拿出，再与后面的挨个拼接</p>
<ol>
<li>先在队列中插入一个空字符 </li>
<li>取出队列中的第一个元素，与后一位数字对应的字符进行挨个拼接 。</li>
<li>重复第二步，直到结束。</li>
</ol>
<h4 id="注意-30"><a href="#注意-30" class="headerlink" title="注意"></a>注意</h4><p><code>let a = [1, 2, 3];</code></p>
<p><code>let b = a;</code></p>
<p><code>let c = a;</code></p>
<p>此代码中a,b,c仍然是<strong>同一个地址</strong>。</p>
<h4 id="思路二-24"><a href="#思路二-24" class="headerlink" title="思路二"></a>思路二</h4><p>回溯。可以穷举所有的可能性，找到所有的可能性。回溯过程中维护一个字符串，表示已有的字母排列。 如果有数字需要被输入，就遍历数字对应的字母进行组合 。 当发现没有数字输入时，说明已经走完了，得到结果。</p>
<h3 id="7-4-全排列-LeetCode46-Medium"><a href="#7-4-全排列-LeetCode46-Medium" class="headerlink" title="7.4 全排列 LeetCode46 Medium"></a>7.4 <a href="https://leetcode.cn/problems/permutations/">全排列</a> LeetCode46 Medium</h3><h4 id="题目-30"><a href="#题目-30" class="headerlink" title="题目"></a>题目</h4><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<h4 id="思路一-29"><a href="#思路一-29" class="headerlink" title="思路一"></a>思路一</h4><p>回溯法.构造一颗生成树，遍历需要全排列的数组，将不同位置的数字与目前树结合起来 ,重复该操作直到需要全排列的数组长度为 0，即表明完成了全排列，因为数字不能重复，所以在每次遍历后应对数组做出处理，之后传入剩余的数组。</p>
<h4 id="注意-31"><a href="#注意-31" class="headerlink" title="注意"></a>注意</h4><p>在递归中应注意不要使用数组的push()方法，最好使用扩展运算符。</p>
<h4 id="思路二-25"><a href="#思路二-25" class="headerlink" title="思路二"></a>思路二</h4><p>插值排列法。遍历需要全排列的数组，将不同位置的数字抽离出来，插入到剩余数组的不同位置，即可得到该数字与另一个数组的全排列结果。 将一个固定的数字，插入到另一个数组 的全排列结果的不同位置， 遍历需要全排列的数组，将不同的数字连接到不同的树上继续全排列剩下的数组与生成的树，当剩余数组长度为0时，表明完成了全排列。</p>
<h2 id="8-排序算法"><a href="#8-排序算法" class="headerlink" title="8. 排序算法"></a>8. 排序算法</h2><h3 id="8-9-搜索旋转排序数组-LeetCode33-Medium"><a href="#8-9-搜索旋转排序数组-LeetCode33-Medium" class="headerlink" title="8.9 搜索旋转排序数组 LeetCode33 Medium"></a>8.9 <a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a> LeetCode33 Medium</h3><h4 id="题目-31"><a href="#题目-31" class="headerlink" title="题目"></a>题目</h4><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<h4 id="思路一-30"><a href="#思路一-30" class="headerlink" title="思路一"></a>思路一</h4><p>先用<code>Math.min.apply(null, nums)</code>和<code>Math.max.apply(null, nums)</code>计算数组中的最大最小值。当目标值大于数组最后一位时，数组查询位置从 0 到数字中在最大位置，当目标值小于等于数组最后一位时，数组查询位置从数组中最小值的位置开始，到数组的最后一 位。 循环二分查询，计算定位数组的中间值，数组的值等于目标查询结束。</p>
<h4 id="注意-32"><a href="#注意-32" class="headerlink" title="注意"></a>注意</h4><p>此方法时间复杂度不为 O(log n)，因为求了最大值与最小值。</p>
<h4 id="思路二-26"><a href="#思路二-26" class="headerlink" title="思路二"></a>思路二</h4><p>定义左右值分别为数组第一个和最后一个的下标 ，中间下标值为最大最小值的平均数 ，如果数组中间数等于目标直接返回下标 。数组的中间值小于数组最后一个值，后半部分还处于升序，如果目标值在这部分数组中，则左下标等于中间值+1，代表目标值在后半部分数组，反之重新定义右下标为中间值-1，目标在前半数组。 数组中间值大于数组最后一个值，代表前半部分数组处于升序，如果目标在前半数组中，右标 更新为中间值-1，反之，左下标更新为中间值+1。循环二分查询，计算定位数组的中间值，数组的值等于目标查询结束。</p>
<h4 id="注意-33"><a href="#注意-33" class="headerlink" title="注意"></a>注意</h4><p>二分查找主要是同过目标值与中间值进行比较，从而直接确定目标值在哪一部分。如果<strong>不是</strong>升序或降序数组，则需要进一步确定目标值位置。</p>
<h3 id="8-10-在排序数组中查找元素的第一个和最后一个位置-LeetCode34-Medium"><a href="#8-10-在排序数组中查找元素的第一个和最后一个位置-LeetCode34-Medium" class="headerlink" title="8.10 在排序数组中查找元素的第一个和最后一个位置 LeetCode34 Medium"></a>8.10 <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a> LeetCode34 Medium</h3><h4 id="题目-32"><a href="#题目-32" class="headerlink" title="题目"></a>题目</h4><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题</p>
<h4 id="思路一-31"><a href="#思路一-31" class="headerlink" title="思路一"></a>思路一</h4><p>二分查找，找到左边第一个不小于目标值的位置 ,然后从位置开始到最后，二分查找，确定右边最后一个符合条件值的位置 ，最后校验下标是否符合，得到结果。</p>
<h3 id="8-12-颜色分类-LeetCode75-Medium"><a href="#8-12-颜色分类-LeetCode75-Medium" class="headerlink" title="8.12. 颜色分类 LeetCode75 Medium"></a>8.12. <a href="https://leetcode.cn/problems/sort-colors/">颜色分类</a> LeetCode75 Medium</h3><h4 id="题目-33"><a href="#题目-33" class="headerlink" title="题目"></a>题目</h4><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库的sort函数的情况下解决这个问题。</p>
<p><strong>进阶：</strong></p>
<ul>
<li>你可以不使用代码库中的排序函数来解决这道题吗？</li>
<li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>
</ul>
<h4 id="思路一-32"><a href="#思路一-32" class="headerlink" title="思路一"></a>思路一</h4><p> 双指针遍历.设定一头一尾两个指针 begin 和 end，然后利用for循环从头开始遍历数组。如果遇到 0，则将该数值与begin指向的值交换，并且使begin++。 如果遇到 2，则将该数值与end指向的值交换，并且使end–。 如果遇到 1，则不做操作。</p>
<h3 id="8-15-合并区间-LeetCode56-Medium"><a href="#8-15-合并区间-LeetCode56-Medium" class="headerlink" title="8.15 合并区间 LeetCode56 Medium"></a>8.15 <a href="https://leetcode.cn/problems/merge-intervals/">合并区间</a> LeetCode56 Medium</h3><h4 id="题目-34"><a href="#题目-34" class="headerlink" title="题目"></a>题目</h4><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<h4 id="思路一-33"><a href="#思路一-33" class="headerlink" title="思路一"></a>思路一</h4><p>先将列表中的区间按照左端点升序排序。定义一个新的数组，用于存储新的数组区间，新数组的第一个值为原数组的第一个值。然后从第二个值开始遍历原数组，比较当前区间的最小值是否大于新数组最后一个区间的最大值， 如果满足则push进入新的数组；又或者比较当前区间的最大值是否大于新新数组的随后一个区间的最大值，若满足则将新数组的最后一个区间的最大值替换成当前区间的最大值。</p>
<h4 id="注意-34"><a href="#注意-34" class="headerlink" title="注意"></a>注意</h4><p>要先进行原数组排序操作，可以降低做题难度。</p>
<h2 id="9-栈和队列"><a href="#9-栈和队列" class="headerlink" title="9. 栈和队列"></a>9. 栈和队列</h2><h3 id="9-6-有效的括号-LeetCode20-Easy"><a href="#9-6-有效的括号-LeetCode20-Easy" class="headerlink" title="9.6 有效的括号 LeetCode20 Easy"></a>9.6 <a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a> LeetCode20 Easy</h3><h4 id="题目-35"><a href="#题目-35" class="headerlink" title="题目"></a>题目</h4><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p>
<h4 id="思路一-34"><a href="#思路一-34" class="headerlink" title="思路一"></a>思路一</h4><p>利用<strong>头插法</strong>建立链栈，如果使用尾插法建立则不易删除节点（即出栈操作）。在遇到左括号的时候，将其入栈。在遇到右括号的时候，刚好就可以与栈中的左括号进行匹配，如果正确，就把左括号出栈 。 如果最终栈为空，说明全部匹配成功。</p>
<h4 id="注意-35"><a href="#注意-35" class="headerlink" title="注意"></a>注意</h4><p>注意<strong>JS的垃圾回收机制</strong>。在链表中:</p>
<p><code>let a = new ListNode(1);</code></p>
<p><code>let b = a;</code></p>
<p><code>a = null;</code></p>
<p>b仍然指向新建的空间，不为空。</p>
<p>另外需要使用<strong>头插法</strong>建立链表。</p>
<h4 id="思路二-27"><a href="#思路二-27" class="headerlink" title="思路二"></a>思路二</h4><p>用 Map 数据类型，建立数组栈。在遇到左括号的时候，将其入栈。在遇到右括号的时候，刚好就可以与栈中的左括号进行匹配，如果正确，就把左括号出栈 。 如果最终栈为空，说明全部匹配成功。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>🔥 LeetCode 热题 HOT 100</title>
    <url>/2022/08/13/%F0%9F%94%A5-LeetCode-%E7%83%AD%E9%A2%98-HOT-100/</url>
    <content><![CDATA[<p>未完善…</p>
<h2 id="1-两数之和-LeetCode1-Easy"><a href="#1-两数之和-LeetCode1-Easy" class="headerlink" title="1. 两数之和 LeetCode1 Easy *"></a>1. <a href="https://leetcode.cn/problems/two-sum/">两数之和</a> LeetCode1 Easy *</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p>
<h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>通过双重循环，暴力枚举每一种组合，再通过判断语句，如果两数满足和为target，则返回它们的数组下标。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>因为题目要求元素在答案里不能重复出现，且可以按任何顺序返回答案，所以部分组合已经遍历过，无需重复遍历。</p>
<h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>利用哈希表，运用Array的some()方法进行处理，将每个元素的值和它的索引加到表中，检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。</p>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>判断成立的条件应为<code>typeof lookup[target - v] ===&quot;number&quot;</code>，如果为<code>lookup[target - v]</code>在下标为<strong>0</strong>时会判断错误。</p>
<h2 id="2-两数相加-LeetCode2-Medium"><a href="#2-两数相加-LeetCode2-Medium" class="headerlink" title="2. 两数相加 LeetCode2 Medium *"></a>2. <a href="https://leetcode.cn/problems/add-two-numbers/">两数相加</a> LeetCode2 Medium *</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<h3 id="思路一-1"><a href="#思路一-1" class="headerlink" title="思路一"></a>思路一</h3><p>由于输入的两个链表都是<strong>逆序</strong>存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。</p>
<h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><p>注意需要保存进位值用于下一位相加，另外当链表遍历完时，如果进位值大于0，应<strong>再加一个结点存储进位值</strong>。</p>
<h3 id="思路二-1"><a href="#思路二-1" class="headerlink" title="思路二"></a>思路二</h3><p>将输入的链表转换为逆序的字符串（<strong>字符串</strong>可以更容易的取出每一位数，无论是正序取出还是逆序取出），再将字符串转换为数（可以考虑使用BigInt,确保精度），然后将两个链表转换的数相加，再转换为字符串，然后逆序放入新的链表。</p>
<h2 id="3-无重复字符的最长子串-LeetCode3-Medium"><a href="#3-无重复字符的最长子串-LeetCode3-Medium" class="headerlink" title="3. 无重复字符的最长子串 LeetCode3 Medium *"></a>3. <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a> LeetCode3 Medium *</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<h3 id="思路一-2"><a href="#思路一-2" class="headerlink" title="思路一"></a>思路一</h3><p>初始化一个数组和最大值， 从前向后遍历字符串， 如果该字符不在数组中（使用Array的indexOf()方法进行判断），则把字符 push 到数组中，并且比较记录下当前最大值。 否则就从头部向外shift字符直到该重复字符被移除（也可以使用slice（）方法直接截断数组,<code>a.slice(a.indexOf(s[i])+1,i+1)</code>）， 如此循环直到结束。</p>
<h3 id="思路二-2"><a href="#思路二-2" class="headerlink" title="思路二"></a>思路二</h3><p>通过for (char of s){}遍历字符串，记录当前正在遍历的不重复字串的子集 string ， 在遍历过程中不断地添加不重复字符，遇到重复字符则截断 string 达到 string 内补字符不重复的条件。</p>
<h2 id="4-寻找两个正序数组的中位数-LeetCode4-Hard"><a href="#4-寻找两个正序数组的中位数-LeetCode4-Hard" class="headerlink" title="4. 寻找两个正序数组的中位数 LeetCode4 Hard"></a>4. <a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a> LeetCode4 Hard</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p>
<p>算法的时间复杂度应该为 O(log (m+n)) </p>
<h2 id="5-最长回文子串-LeetCode5-Medium"><a href="#5-最长回文子串-LeetCode5-Medium" class="headerlink" title="5. 最长回文子串 LeetCode5 Medium *"></a>5. <a href="https://leetcode.cn/problems/longest-palindromic-substring/">最长回文子串</a> LeetCode5 Medium *</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<h3 id="思路一-3"><a href="#思路一-3" class="headerlink" title="思路一"></a>思路一</h3><p>暴力解法。用三个嵌套的for循环，列举所有的子串并判断其是否为回文子串，每次判断后记录此子串并与前一次的子串进行长度比较选取较大的子串。</p>
<h3 id="思路二-3"><a href="#思路二-3" class="headerlink" title="思路二"></a>思路二</h3><p>中心扩展。回文子串一定是对称的，所以我们可以每次选择一个中心，然后从中心向两边扩展判断左右字符是否相等。 中心点的选取有两种情况： 当长度为奇数时，以单个字符为中心； 当长度为偶数时，以两个字符之间的空隙为中心。</p>
<h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><p>String的slice方法，<strong>s.slice(++i,j)<strong>在执行时</strong>第一个参数为i</strong>而非i+1,应写为++i。</p>
<h3 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h3><p>动态规划。动态规划算法的核心就是记住已经解决过的子问题的解。根据字符串的长度，建立一个矩阵 dp, 通过不同情况的判断条件，通过 dp[i][j]表示 s[i] 至 s[j] 所代 表的子串是否是回文子串。不同长度的子串，根据不同的条件进行判断是否为回文子串。长度为 1，一定回文 ；长度为 2 或 3，判断首尾是否相同：s[i] &#x3D;&#x3D;&#x3D; s[j] ；长度 &gt; 3, 首尾字符相同，且去掉首尾之后的子串仍为回文。</p>
<h3 id="注意-4"><a href="#注意-4" class="headerlink" title="注意"></a>注意</h3><p>使用双层for循环遍历时，注意外层表示长度，内层表示字符串的开始位置。如果外层表示开始位置，内层表示长度，则在长度&gt;3时判断<strong>去掉首尾之后的子串</strong>是否为回文会有误。</p>
<h2 id="6-正则表达式匹配-LeetCode10-Hard"><a href="#6-正则表达式匹配-LeetCode10-Hard" class="headerlink" title="6. 正则表达式匹配 LeetCode10 Hard"></a>6. <a href="https://leetcode.cn/problems/regular-expression-matching/">正则表达式匹配</a> LeetCode10 Hard</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<ul>
<li>‘.’ 匹配任意单个字符</li>
<li>‘*’ 匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<h2 id="7-盛最多水的容器-LeetCode11-Medium"><a href="#7-盛最多水的容器-LeetCode11-Medium" class="headerlink" title="7. 盛最多水的容器 LeetCode11 Medium"></a>7. <a href="https://leetcode.cn/problems/container-with-most-water/">盛最多水的容器</a> LeetCode11 Medium</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p>
<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p>说明：你不能倾斜容器。</p>
<h3 id="思路一-4"><a href="#思路一-4" class="headerlink" title="思路一"></a>思路一</h3><p>双指针解法。开始双指针指向数组的左右边界，然后每次移动较小高度的那一边，因为移动会减小宽度，又因面积受限于较短边，如果移动较高的那一边那么只会减小宽度而高度不可能会增加。另外其实可以在每次移动后对移动后的边的高度与未移动之前的高度进行比较，如果高度减小则可以不对当前移动进行面积计算，因为移动后宽度减小，而如果移动的边高度减小，那么面积只可能减小。</p>
<h3 id="思路二-4"><a href="#思路二-4" class="headerlink" title="思路二"></a>思路二</h3><p>双for循环，但是<strong>时间会超时</strong>，不做详解。</p>
<h2 id="8-三数之和-LeetCode15-Medium"><a href="#8-三数之和-LeetCode15-Medium" class="headerlink" title="8. 三数之和 LeetCode15 Medium *"></a>8. <a href="https://leetcode.cn/problems/3sum/">三数之和</a> LeetCode15 Medium *</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<h3 id="思路一-5"><a href="#思路一-5" class="headerlink" title="思路一"></a>思路一</h3><p>首先对数组进行排序，便于在插入的时候去重，进行双指针遍历时，遇到重复的数就方便跳过。设两个指针指向数组首尾，每次计算两个指针所指数与每次遍历的数三数之和，因为数组已经从小到大排序了，所以如果三数之和大于0则尾指针前移，小于0则首指针后移，如果等于0则添加此组合，并进行去重。</p>
<h3 id="注意-5"><a href="#注意-5" class="headerlink" title="注意"></a>注意</h3><p>在数组中因避免这种写法：while(left&lt;right&amp;&amp;r&#x3D;&#x3D;&#x3D;<strong>nums[right-1])</strong>{right–;}，在加粗出容易超出边界。</p>
<h3 id="思路二-5"><a href="#思路二-5" class="headerlink" title="思路二"></a>思路二</h3><p>三重循环，但是<strong>时间会超时</strong>，不做详解。</p>
<h2 id="9-电话号码的字母组合-LeetCode17-Medium"><a href="#9-电话号码的字母组合-LeetCode17-Medium" class="headerlink" title="9. 电话号码的字母组合 LeetCode17 Medium *"></a>9. <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">电话号码的字母组合</a> LeetCode17 Medium *</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png"></p>
<h3 id="思路一-6"><a href="#思路一-6" class="headerlink" title="思路一"></a>思路一</h3><p>利用队列的先进先出的特点，把队列中的第一个元素拿出，再与后面的挨个拼接</p>
<ol>
<li>先在队列中插入一个空字符 </li>
<li>取出队列中的第一个元素，与后一位数字对应的字符进行挨个拼接 。</li>
<li>重复第二步，直到结束。</li>
</ol>
<h3 id="注意-6"><a href="#注意-6" class="headerlink" title="注意"></a>注意</h3><p><code>let a = [1, 2, 3];</code></p>
<p><code>let b = a;</code></p>
<p><code>let c = a;</code></p>
<p>此代码中a,b,c仍然是<strong>同一个地址</strong>。</p>
<h3 id="思路二-6"><a href="#思路二-6" class="headerlink" title="思路二"></a>思路二</h3><p>回溯。可以穷举所有的可能性，找到所有的可能性。回溯过程中维护一个字符串，表示已有的字母排列。 如果有数字需要被输入，就遍历数字对应的字母进行组合 。 当发现没有数字输入时，说明已经走完了，得到结果。</p>
<h2 id="10-删除链表的倒数第-N-个结点-LeetCode19-Medium"><a href="#10-删除链表的倒数第-N-个结点-LeetCode19-Medium" class="headerlink" title="10. 删除链表的倒数第 N 个结点  LeetCode19 Medium *"></a>10. <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a>  LeetCode19 Medium *</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<h3 id="思路一-7"><a href="#思路一-7" class="headerlink" title="思路一"></a>思路一</h3><p> 双指针法。先设first和second指向head，让first 指针前进 n，如果 first为空，说明要删除的节点正是 head 节点，那么直接返回 head 的下一个节点。如果不为空，则让让 second 从 head 开始和 first 一起前进，直到 first 到了最后，此时 second 的下一个节点就是要删除的节点，做出 second.next &#x3D; second.next.next处理。</p>
<h3 id="注意-7"><a href="#注意-7" class="headerlink" title="注意"></a>注意</h3><p>注意first为空时的处理，还有<strong>second.next &#x3D; second.next.nex</strong>t这一步，而不是second.next&#x3D;first，这仅适用于n为2时。</p>
<h3 id="思路二-7"><a href="#思路二-7" class="headerlink" title="思路二"></a>思路二</h3><p> 单向链表成为双向链表。先遍历，让单向链表成为双向链表，先找到其尾节点，从这个节点向前查找，n–，直到n&#x3D;1时，此时的节点就是我们要找的节点，然后直接删除。</p>
<h2 id="11-有效的括号-LeetCode20-Easy"><a href="#11-有效的括号-LeetCode20-Easy" class="headerlink" title="11 有效的括号 LeetCode20 Easy *"></a>11 <a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a> LeetCode20 Easy *</h2><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p>
<h3 id="思路一-8"><a href="#思路一-8" class="headerlink" title="思路一"></a>思路一</h3><p>利用<strong>头插法</strong>建立链栈，如果使用尾插法建立则不易删除节点（即出栈操作）。在遇到左括号的时候，将其入栈。在遇到右括号的时候，刚好就可以与栈中的左括号进行匹配，如果正确，就把左括号出栈 。 如果最终栈为空，说明全部匹配成功。</p>
<h3 id="注意-8"><a href="#注意-8" class="headerlink" title="注意"></a>注意</h3><p>注意<strong>JS的垃圾回收机制</strong>。在链表中:</p>
<p><code>let a = new ListNode(1);</code></p>
<p><code>let b = a;</code></p>
<p><code>a = null;</code></p>
<p>b仍然指向新建的空间，不为空。</p>
<p>另外需要使用<strong>头插法</strong>建立链表。</p>
<h3 id="思路二-8"><a href="#思路二-8" class="headerlink" title="思路二"></a>思路二</h3><p>用 Map 数据类型，建立数组栈。在遇到左括号的时候，将其入栈。在遇到右括号的时候，刚好就可以与栈中的左括号进行匹配，如果正确，就把左括号出栈 。 如果最终栈为空，说明全部匹配成功。</p>
<h2 id="12-合并两个有序链表-LeetCode21-Easy"><a href="#12-合并两个有序链表-LeetCode21-Easy" class="headerlink" title="12 合并两个有序链表 LeetCode21 Easy *"></a>12 <a href="https://leetcode.cn/problems/merge-two-sorted-lists/">合并两个有序链表</a> LeetCode21 Easy *</h2><h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<h3 id="思路一-9"><a href="#思路一-9" class="headerlink" title="思路一"></a>思路一</h3><p>创建一个新链表，通过判断两个链表当前值，将较小值放到新链表的下个节点，较小值的链表重新赋值为其下一节点，直到参数链表都为空时结束。</p>
<h3 id="思路二-9"><a href="#思路二-9" class="headerlink" title="思路二"></a>思路二</h3><p>用递归的方式， 若两个链表中有一个链表为空，则返回另一个链表,依次比较两个链表中首项的大小，保留数值小的为链表当前值，直到一个链表参数为空则结束。</p>
<h2 id="13-括号生成-LeetCode22-Medium"><a href="#13-括号生成-LeetCode22-Medium" class="headerlink" title="13 括号生成 LeetCode22 Medium *"></a>13 <a href="https://leetcode.cn/problems/generate-parentheses/">括号生成</a> LeetCode22 Medium *</h2><h3 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h3><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<h3 id="思路一-10"><a href="#思路一-10" class="headerlink" title="思路一"></a>思路一</h3><p>采用回溯法，如果自定义的字符串长度刚好满足条件，那么就说明这个组合是正确的的，把它放入数组。 否则，递归执行添加左括号，添加右括号的操作。递归结束条件为结果字符串长度等于左右括号的总个数（2n），则返回最终结果。</p>
<h2 id="14-合并K个升序链表-LeetCode23-Hard"><a href="#14-合并K个升序链表-LeetCode23-Hard" class="headerlink" title="14 合并K个升序链表 LeetCode23 Hard"></a>14 <a href="https://leetcode.cn/problems/merge-k-sorted-lists/">合并K个升序链表</a> LeetCode23 Hard</h2><h3 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<h2 id="15-下一个排列-LeetCode31-Medium"><a href="#15-下一个排列-LeetCode31-Medium" class="headerlink" title="15 下一个排列 LeetCode31 Medium"></a>15 <a href="https://leetcode.cn/problems/next-permutation/">下一个排列</a> LeetCode31 Medium</h2><h3 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h3><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p>
<p>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<p>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p>
<p>必须 原地 修改，只允许使用额外常数空间。</p>
<h3 id="思路一-11"><a href="#思路一-11" class="headerlink" title="思路一"></a>思路一</h3><p>从后向前查找第一个相邻升序的元素对 (i,j)，满足 A[i] &lt; A[j]。此时 [j,end) 必然是降序,在 [j,end) 从后向前查找第一个满足 A[i] &lt; A[k] 的 k。A[i]、A[k] 分别就是上文所说的「小数」、「大数」,将 A[i] 与 A[k] 交换,可以断定这时 [j,end) 必然是降序，逆置 [j,end)，使其升序.</p>
<h3 id="注意-9"><a href="#注意-9" class="headerlink" title="注意"></a>注意</h3><p>注意题目要求中的必须原地修改，不能使用splice（）截取再使用concat()合并。另外需要注意sort()默认是字典排序（ 例如：9&gt;19）。</p>
<h2 id="16-最长有效括号-LeetCode32-Hard"><a href="#16-最长有效括号-LeetCode32-Hard" class="headerlink" title="16 最长有效括号 LeetCode32 Hard"></a>16 <a href="https://leetcode.cn/problems/longest-valid-parentheses/">最长有效括号</a> LeetCode32 Hard</h2><h3 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h3><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<h2 id="17-搜索旋转排序数组-LeetCode33-Medium"><a href="#17-搜索旋转排序数组-LeetCode33-Medium" class="headerlink" title="17. 搜索旋转排序数组 LeetCode33 Medium *"></a>17. <a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a> LeetCode33 Medium *</h2><h3 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h3><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<h3 id="思路一-12"><a href="#思路一-12" class="headerlink" title="思路一"></a>思路一</h3><p>先用<code>Math.min.apply(null, nums)</code>和<code>Math.max.apply(null, nums)</code>计算数组中的最大最小值。当目标值大于数组最后一位时，数组查询位置从 0 到数字中在最大位置，当目标值小于等于数组最后一位时，数组查询位置从数组中最小值的位置开始，到数组的最后一 位。 循环二分查询，计算定位数组的中间值，数组的值等于目标查询结束。</p>
<h3 id="注意-10"><a href="#注意-10" class="headerlink" title="注意"></a>注意</h3><p>此方法时间复杂度不为 O(log n)，因为求了最大值与最小值。</p>
<h3 id="思路二-10"><a href="#思路二-10" class="headerlink" title="思路二"></a>思路二</h3><p>定义左右值分别为数组第一个和最后一个的下标 ，中间下标值为最大最小值的平均数 ，如果数组中间数等于目标直接返回下标 。数组的中间值小于数组最后一个值，后半部分还处于升序，如果目标值在这部分数组中，则左下标等于中间值+1，代表目标值在后半部分数组，反之重新定义右下标为中间值-1，目标在前半数组。 数组中间值大于数组最后一个值，代表前半部分数组处于升序，如果目标在前半数组中，右标 更新为中间值-1，反之，左下标更新为中间值+1。循环二分查询，计算定位数组的中间值，数组的值等于目标查询结束。</p>
<h3 id="注意-11"><a href="#注意-11" class="headerlink" title="注意"></a>注意</h3><p>二分查找主要是同过目标值与中间值进行比较，从而直接确定目标值在哪一部分。如果<strong>不是</strong>升序或降序数组，则需要进一步确定目标值位置。</p>
<h2 id="18-在排序数组中查找元素的第一个和最后一个位置-LeetCode34-Medium"><a href="#18-在排序数组中查找元素的第一个和最后一个位置-LeetCode34-Medium" class="headerlink" title="18. 在排序数组中查找元素的第一个和最后一个位置 LeetCode34 Medium *"></a>18. <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a> LeetCode34 Medium *</h2><h3 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h3><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题</p>
<h3 id="思路一-13"><a href="#思路一-13" class="headerlink" title="思路一"></a>思路一</h3><p>二分查找，找到左边第一个不小于目标值的位置 ,然后从位置开始到最后，二分查找，确定右边最后一个符合条件值的位置 ，最后校验下标是否符合，得到结果。</p>
<h2 id="19-组合总和-LeetCode39-Medium"><a href="#19-组合总和-LeetCode39-Medium" class="headerlink" title="19. 组合总和 LeetCode39 Medium"></a>19. <a href="https://leetcode.cn/problems/combination-sum/">组合总和</a> LeetCode39 Medium</h2><h3 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h3><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p>
<h3 id="思路一-14"><a href="#思路一-14" class="headerlink" title="思路一"></a>思路一</h3><p>回溯算法。递归的终止条件为已经找到一组数和为目标值或者数组中的数被全部遍历完。在每次递归中，我们可以选择跳过不用当前数，即搜索下标+1。也可以选择使用当前数，目标值减去当前数。因为到每个数字可以被无限制重复选取，因此搜索的下标不变。</p>
<h2 id="20-接雨水-LeetCode42-Hard"><a href="#20-接雨水-LeetCode42-Hard" class="headerlink" title="20. 接雨水 LeetCode42 Hard"></a>20. <a href="https://leetcode.cn/problems/trapping-rain-water/">接雨水</a> LeetCode42 Hard</h2><h3 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h3><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<h2 id="21-全排列-LeetCode46-Medium"><a href="#21-全排列-LeetCode46-Medium" class="headerlink" title="21. 全排列 LeetCode46 Medium *"></a>21. <a href="https://leetcode.cn/problems/permutations/">全排列</a> LeetCode46 Medium *</h2><h3 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<h3 id="思路一-15"><a href="#思路一-15" class="headerlink" title="思路一"></a>思路一</h3><p>回溯法.构造一颗生成树，遍历需要全排列的数组，将不同位置的数字与目前树结合起来 ,重复该操作直到需要全排列的数组长度为 0，即表明完成了全排列，因为数字不能重复，所以在每次遍历后应对数组做出处理，之后传入剩余的数组。</p>
<h3 id="注意-12"><a href="#注意-12" class="headerlink" title="注意"></a>注意</h3><p>在递归中应注意不要使用数组的push()方法，最好使用扩展运算符。</p>
<h3 id="思路二-11"><a href="#思路二-11" class="headerlink" title="思路二"></a>思路二</h3><p>插值排列法。遍历需要全排列的数组，将不同位置的数字抽离出来，插入到剩余数组的不同位置，即可得到该数字与另一个数组的全排列结果。 将一个固定的数字，插入到另一个数组 的全排列结果的不同位置， 遍历需要全排列的数组，将不同的数字连接到不同的树上继续全排列剩下的数组与生成的树，当剩余数组长度为0时，表明完成了全排列。</p>
<h2 id="22-旋转图像-LeetCode48-Medium"><a href="#22-旋转图像-LeetCode48-Medium" class="headerlink" title="22. 旋转图像 LeetCode48 Medium *"></a>22. <a href="https://leetcode.cn/problems/rotate-image/">旋转图像</a> LeetCode48 Medium *</h2><h3 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h3><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<h3 id="思路一-16"><a href="#思路一-16" class="headerlink" title="思路一"></a>思路一</h3><p>先将矩阵沿左上角到右下角的对角线进行对称,运用for双层循环，内层循环的计数值的初始值为外层循环的计数值，然后将矩阵沿垂直中线对称即可。运用for双层循环，内层循环计数值小于Math.floor(n &#x2F; 2)，n为矩阵长度。</p>
<h3 id="注意-13"><a href="#注意-13" class="headerlink" title="注意"></a>注意</h3><p>注意两个for双层循环的内层循环计数值的初始值即范围。</p>
<h2 id="23-字母异位词分组-LeetCode49-Medium"><a href="#23-字母异位词分组-LeetCode49-Medium" class="headerlink" title="23. 字母异位词分组 LeetCode49 Medium *"></a>23. <a href="https://leetcode.cn/problems/group-anagrams/">字母异位词分组</a> LeetCode49 Medium *</h2><h3 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p>
<p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>
<h3 id="思路一-17"><a href="#思路一-17" class="headerlink" title="思路一"></a>思路一</h3><p>排序分类。先创建个空对象，用于储存字母异位词，然后创建个空数组，用与返回结果。遍历数组里的元素，将每个字母异位词进行排序，并将排序后的字符串作为 key，可知 key 值一样的即为字母异位 词，将他们置于同一个数组中， 待上述遍历结束，再遍历对象，将 对象的每一个值，push 到数组中。</p>
<h3 id="思路二-12"><a href="#思路二-12" class="headerlink" title="思路二"></a>思路二</h3><p>计数分类。和思路一的不同在于判断两个字符串是否为字母异位词的方法不同。我们先遍历数组，每次都创建一个长度为 26，元素全是 0 的数组，用于记录每个单词中每个字符出现的次数；然后将其转化为字符串作为 key，将 key 值一样的字母异位词置于同一个数组中。最 后返回数组。</p>
<h3 id="注意-14"><a href="#注意-14" class="headerlink" title="注意"></a>注意</h3><p>数组间不能直接判断是否相同，可以运用JSON.stringify()转换数组为字符串进行判断。</p>
<h2 id="24-最大子数组和-LeetCode53-Medium"><a href="#24-最大子数组和-LeetCode53-Medium" class="headerlink" title="24. 最大子数组和 LeetCode53 Medium *"></a>24. <a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a> LeetCode53 Medium *</h2><h3 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中的一个连续部分。</p>
<p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>
<h3 id="思路一-18"><a href="#思路一-18" class="headerlink" title="思路一"></a>思路一</h3><p>从数组获取第一个值为最大值和中间值 ,遍历数组，如果中间值大于0,则和中间值相加，相加结果和最大值比较，较大值赋值给最大值。如果中间值小于0，则将当前值作为中间值。</p>
<h3 id="思路二-13"><a href="#思路二-13" class="headerlink" title="思路二"></a>思路二</h3><p>分治方法。运用递归，每次求得左右两半部分各自最大子数组和，然后处理两个部分一起的最大子数组和。递归结束条件为左右下标相等。</p>
<h2 id="25-跳跃游戏-LeetCode55-Medium"><a href="#25-跳跃游戏-LeetCode55-Medium" class="headerlink" title="25. 跳跃游戏 LeetCode55 Medium *"></a>25. <a href="https://leetcode.cn/problems/jump-game/">跳跃游戏</a> LeetCode55 Medium *</h2><h3 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h3><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标。</p>
<h3 id="思路一-19"><a href="#思路一-19" class="headerlink" title="思路一"></a>思路一</h3><p>贪心。先初始化最远位置为0，然后遍历数组，如果当前位置能到达，并且当前位置+跳数&gt;最远位置，就更新最远位置， 每次循环都比较当前最远位置和当前数组下标，如果最远距离小于等于当前下标就返回false。</p>
<h3 id="思路二-14"><a href="#思路二-14" class="headerlink" title="思路二"></a>思路二</h3><p>动态规划。遍历数组，每到一个点 ，我们就去判断是否可以到达当前点；如果可以，就记录true，否则为 false，最后判断是否可以到达最后一个点。</p>
<h2 id="26-合并区间-LeetCode56-Medium"><a href="#26-合并区间-LeetCode56-Medium" class="headerlink" title="26. 合并区间 LeetCode56 Medium *"></a>26. <a href="https://leetcode.cn/problems/merge-intervals/">合并区间</a> LeetCode56 Medium *</h2><h3 id="题目-25"><a href="#题目-25" class="headerlink" title="题目"></a>题目</h3><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<h3 id="思路一-20"><a href="#思路一-20" class="headerlink" title="思路一"></a>思路一</h3><p>先将列表中的区间按照左端点升序排序。定义一个新的数组，用于存储新的数组区间，新数组的第一个值为原数组的第一个值。然后从第二个值开始遍历原数组，比较当前区间的最小值是否大于新数组最后一个区间的最大值， 如果满足则push进入新的数组；又或者比较当前区间的最大值是否大于新新数组的随后一个区间的最大值，若满足则将新数组的最后一个区间的最大值替换成当前区间的最大值。</p>
<h3 id="注意-15"><a href="#注意-15" class="headerlink" title="注意"></a>注意</h3><p>要先进行原数组排序操作，可以降低做题难度。</p>
<h2 id="27-不同路径-LeetCode62-Medium"><a href="#27-不同路径-LeetCode62-Medium" class="headerlink" title="27. 不同路径 LeetCode62 Medium *"></a>27. <a href="https://leetcode.cn/problems/unique-paths/">不同路径</a> LeetCode62 Medium *</h2><h3 id="题目-26"><a href="#题目-26" class="headerlink" title="题目"></a>题目</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<h3 id="思路一-21"><a href="#思路一-21" class="headerlink" title="思路一"></a>思路一</h3><p>动态规划。利用双层for循环，状态转移方程为 dp[i][j] &#x3D; dp[i − 1][j] + dp[i][j − 1]。</p>
<h3 id="思路二-15"><a href="#思路二-15" class="headerlink" title="思路二"></a>思路二</h3><p>深度优先搜索+记忆化数组。dfs[i][j] &#x3D; dfs[i − 1][j] + dfs[i][j − 1]。开辟一个记忆数组记录结果。</p>
<h3 id="思路三-1"><a href="#思路三-1" class="headerlink" title="思路三"></a>思路三</h3><p>组合数学。从左上角到右下角的过程中，我们需要移动 m+n-2 次，其中有 m-1次向下移动，n-1次向右移动。因此路径的总数，就等于从 m+n-2次移动中选择 m-1次向下移动的方案数。</p>
<h2 id="28-最小路径和-LeetCode64-Medium"><a href="#28-最小路径和-LeetCode64-Medium" class="headerlink" title="28. 最小路径和 LeetCode64 Medium"></a>28. <a href="https://leetcode.cn/problems/minimum-path-sum/">最小路径和</a> LeetCode64 Medium</h2><h3 id="题目-27"><a href="#题目-27" class="headerlink" title="题目"></a>题目</h3><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<h3 id="思路一-22"><a href="#思路一-22" class="headerlink" title="思路一"></a>思路一</h3><p>动态规划。创建二维数组dp[i][j]，与原始网格的大小相同，dp[i][j]表示从左上角出发到 (i,j)(i,j) 位置的最小路径和。元素对应的最小路径和等于其上方相邻元素与其左方相邻元素两者对应的最小路径和中的最小值加上当前元素的值。最后得到dp[m-1][n-1]即为从网格左上角到网格右下角的最小路径和。</p>
<h2 id="29-爬楼梯-LeetCode70-Easy"><a href="#29-爬楼梯-LeetCode70-Easy" class="headerlink" title="29. 爬楼梯 LeetCode70 Easy *"></a>29. <a href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a> LeetCode70 Easy *</h2><h3 id="题目-28"><a href="#题目-28" class="headerlink" title="题目"></a>题目</h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<h3 id="思路一-23"><a href="#思路一-23" class="headerlink" title="思路一"></a>思路一</h3><p>递归+记忆化数组。递归函数：f(n) &#x3D; f(n − 1) + f(n − 2)，创建一个记忆化数组，记录楼层计算过的结果，降低时间复杂度。</p>
<h3 id="思路二-16"><a href="#思路二-16" class="headerlink" title="思路二"></a>思路二</h3><p>动态规划+滚动数组。f(n) &#x3D; f(n − 1) + f(n − 2)。但是由于这里的f(n)只和 f(n - 1) 与 f(n - 2)有关，所以可以用滚动数组思想.</p>
<h2 id="30-编辑距离-LeetCode72-Hard"><a href="#30-编辑距离-LeetCode72-Hard" class="headerlink" title="30. 编辑距离 LeetCode72 Hard"></a>30. <a href="https://leetcode.cn/problems/edit-distance/">编辑距离</a> LeetCode72 Hard</h2><h3 id="题目-29"><a href="#题目-29" class="headerlink" title="题目"></a>题目</h3><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<h2 id="31-颜色分类-LeetCode75-Medium"><a href="#31-颜色分类-LeetCode75-Medium" class="headerlink" title="31. 颜色分类 LeetCode75 Medium *"></a>31. <a href="https://leetcode.cn/problems/sort-colors/">颜色分类</a> LeetCode75 Medium *</h2><h3 id="题目-30"><a href="#题目-30" class="headerlink" title="题目"></a>题目</h3><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库的sort函数的情况下解决这个问题。</p>
<p><strong>进阶：</strong></p>
<ul>
<li>你可以不使用代码库中的排序函数来解决这道题吗？</li>
<li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>
</ul>
<h3 id="思路一-24"><a href="#思路一-24" class="headerlink" title="思路一"></a>思路一</h3><p> 双指针遍历.设定一头一尾两个指针 begin 和 end，然后利用for循环从头开始遍历数组。如果遇到 0，则将该数值与begin指向的值交换，并且使begin++。 如果遇到 2，则将该数值与end指向的值交换，并且使end–。 如果遇到 1，则不做操作。</p>
<h2 id="32-最小覆盖子串-LeetCode76-Hard"><a href="#32-最小覆盖子串-LeetCode76-Hard" class="headerlink" title="32. 最小覆盖子串 LeetCode76 Hard"></a>32. <a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a> LeetCode76 Hard</h2><h3 id="题目-31"><a href="#题目-31" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>
<p>注意：</p>
<p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p>
<p><strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？</p>
<h2 id="33-子集-LeetCode78-Medium"><a href="#33-子集-LeetCode78-Medium" class="headerlink" title="33. 子集 LeetCode78 Medium"></a>33. <a href="https://leetcode.cn/problems/subsets/">子集</a> LeetCode78 Medium</h2><h3 id="题目-32"><a href="#题目-32" class="headerlink" title="题目"></a>题目</h3><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库的sort函数的情况下解决这个问题。</p>
<p><strong>进阶：</strong></p>
<ul>
<li>你可以不使用代码库中的排序函数来解决这道题吗？</li>
<li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>
</ul>
<h3 id="思路一-25"><a href="#思路一-25" class="headerlink" title="思路一"></a>思路一</h3><p> 双指针遍历.设定一头一尾两个指针 begin 和 end，然后利用for循环从头开始遍历数组。如果遇到 0，则将该数值与begin指向的值交换，并且使begin++。 如果遇到 2，则将该数值与end指向的值交换，并且使end–。 如果遇到 1，则不做操作。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
